# functions\index.js
```
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const crypto = require('crypto');

// ç¢ºä¿åªåˆå§‹åŒ–ä¸€æ¬¡
if (!admin.apps.length) {
  admin.initializeApp();
}

const { checkAdminExists, createInitialAdmin, sendOtpToPhone, verifyOtpCode, setProjectInfo, getTotalCapital, getAssignedCapitalSum, createManager } = require('./admin');
exports.checkAdminExists = checkAdminExists;
exports.createInitialAdmin = createInitialAdmin;
exports.sendOtpToPhone = sendOtpToPhone;
exports.verifyOtpCode = verifyOtpCode;
exports.setProjectInfo = setProjectInfo;
exports.getTotalCapital = getTotalCapital;
exports.getAssignedCapitalSum = getAssignedCapitalSum;
exports.createManager = createManager;

// ğŸ”¥ ä¿®å¾©ï¼šæ¨™æº–åŒ–æ‰‹æ©Ÿè™Ÿç¢¼æ ¼å¼
function normalizePhoneNumber(phoneNumber) {
  // ç§»é™¤æ‰€æœ‰ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦
  let cleaned = phoneNumber.replace(/[\s\-\(\)]/g, '');
  
  // å¦‚æœä»¥ +60 æˆ– 60 é–‹é ­ï¼Œç§»é™¤å®ƒ
  if (cleaned.startsWith('+60')) {
    cleaned = cleaned.substring(3);
  } else if (cleaned.startsWith('60')) {
    cleaned = cleaned.substring(2);
  }
  
  // å¦‚æœä»¥ 0 é–‹é ­ï¼Œç§»é™¤å®ƒ
  if (cleaned.startsWith('0')) {
    cleaned = cleaned.substring(1);
  }
  
  return cleaned;
}

// ğŸ”¥ ä¿®å¾©ï¼šloginWithPin å‡½æ•¸
exports.loginWithPin = functions.https.onCall(async (data, context) => {
  try {
    // å…¼å®¹å…©ç¨®å‚³åƒæ–¹å¼
    const { phoneNumber, pin, organizationId, eventId } = data.data || data;
    
    console.log('[loginWithPin] Received:', { 
      phoneNumber, 
      organizationId, 
      eventId, 
      hasPin: !!pin
    });
    
    // é©—è­‰å¿…å¡«å­—æ®µ
    if (!phoneNumber || !pin) {
      throw new functions.https.HttpsError("invalid-argument", "è«‹æä¾›æ‰‹æ©Ÿè™Ÿç¢¼èˆ‡å¯†ç¢¼");
    }
    if (!organizationId || !eventId) {
      throw new functions.https.HttpsError("invalid-argument", "è«‹æä¾›çµ„ç¹”èˆ‡æ´»å‹•ä¿¡æ¯");
    }
    
    // ğŸ”¥ æ¨™æº–åŒ–æ‰‹æ©Ÿè™Ÿç¢¼
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    console.log('[loginWithPin] Normalized phone:', normalizedPhone);
    
    // ğŸ”¥ ä¿®å¾©ï¼šæ­£ç¢ºçš„é›†åˆè·¯å¾‘
    const collectionPath = `organizations/${organizationId}/events/${eventId}/users`;
    console.log('[loginWithPin] Querying path:', collectionPath);
    
    // ğŸ”¥ ä¿®å¾©ï¼šæŸ¥è©¢æ™‚å˜—è©¦å¤šç¨®æ‰‹æ©Ÿè™Ÿæ ¼å¼
    const phoneVariants = [
      normalizedPhone,           // ä¾‹å¦‚: 123456789
      `0${normalizedPhone}`,     // ä¾‹å¦‚: 0123456789
      `60${normalizedPhone}`,    // ä¾‹å¦‚: 60123456789
      phoneNumber                // åŸå§‹è¼¸å…¥
    ];
    
    console.log('[loginWithPin] Trying phone variants:', phoneVariants);
    
    let userDoc = null;
    let usersSnap = null;
    
    // å˜—è©¦æ¯ç¨®æ ¼å¼
    for (const variant of phoneVariants) {
      usersSnap = await admin.firestore()
        .collection(collectionPath)
        .where("basicInfo.phoneNumber", "==", variant)
        .limit(1)
        .get();
      
      if (!usersSnap.empty) {
        userDoc = usersSnap.docs[0];
        console.log('[loginWithPin] Found user with phone variant:', variant);
        break;
      }
    }
    
    if (!userDoc) {
      console.log('[loginWithPin] User not found for any phone variant');
      throw new functions.https.HttpsError("not-found", "æŸ¥ç„¡æ­¤æ‰‹æ©Ÿè™Ÿç¢¼");
    }
    
    const userData = userDoc.data();
    console.log('[loginWithPin] User data found:', {
      id: userDoc.id,
      phoneNumber: userData.basicInfo?.phoneNumber,
      roles: userData.roles
    });
    
    // ğŸ”¥ é©—è­‰å¯†ç¢¼
    const passwordSalt = userData.basicInfo?.passwordSalt || userData.basicInfo?.pinSalt;
    const storedHash = userData.basicInfo?.passwordHash || userData.basicInfo?.pinHash;
    
    if (!passwordSalt || !storedHash) {
      throw new functions.https.HttpsError("failed-precondition", "ç”¨æˆ¶å¯†ç¢¼è³‡æ–™ä¸å®Œæ•´");
    }
    
    const passwordHash = crypto.createHash("sha256").update(pin + passwordSalt).digest("hex");
    
    if (passwordHash !== storedHash) {
      throw new functions.https.HttpsError("permission-denied", "å¯†ç¢¼éŒ¯èª¤");
    }
    
    // ğŸ”¥ ä¿®å¾©ï¼šç”Ÿæˆæˆ–ç²å– authUid
    const authUid = `phone_60${normalizedPhone}`;
    console.log('[loginWithPin] Using authUid:', authUid);
    
    let userRecord;
    try {
      userRecord = await admin.auth().getUser(authUid);
      console.log('[loginWithPin] Existing auth user found');
    } catch (error) {
      console.log('[loginWithPin] Creating new auth user');
      userRecord = await admin.auth().createUser({
        uid: authUid,
        displayName: userData.basicInfo?.englishName || userData.basicInfo?.chineseName || phoneNumber
      });
    }
    
    // ğŸ”¥ ç”Ÿæˆè‡ªå®šç¾©ä»¤ç‰Œ
    const customToken = await admin.auth().createCustomToken(authUid);
    
    // ğŸ”¥ æ›´æ–°ç”¨æˆ¶æ–‡æª”çš„ authUidï¼ˆå¦‚æœä¸å­˜åœ¨æˆ–ä¸ä¸€è‡´ï¼‰
    const currentAuthUid = userData.authUid || userData.authId || userData.accountStatus?.authUid;
    if (currentAuthUid !== authUid) {
      console.log(`[loginWithPin] Updating authUid from ${currentAuthUid} to ${authUid}`);
      await userDoc.ref.update({ 
        authUid: authUid,
        'accountStatus.authUid': authUid,
        'accountStatus.updatedAt': new Date()
      });
    }
    
    // ğŸ”¥ æ§‹å»ºè¿”å›çš„ç”¨æˆ¶è³‡æ–™
    const userProfile = {
      id: userDoc.id,
      orgId: organizationId,
      eventId: eventId,
      authUid: authUid,
      basicInfo: userData.basicInfo,
      roles: userData.roles || [],
      identityTag: userData.basicInfo?.identityTag || "",
      roleSpecificData: userData.roleSpecificData || {}
    };
    
    console.log('[loginWithPin] Login successful, returning profile');
    
    return {
      customToken,
      userProfile,
      chineseName: userData.basicInfo?.chineseName || "",
      roles: userData.roles || [],
      redirectUrl: getRedirectUrl(userData.roles || [])
    };
    
  } catch (error) {
    console.error('[loginWithPin] Error:', error);
    
    // å¦‚æœæ˜¯å·²çŸ¥çš„ HttpsErrorï¼Œç›´æ¥æ‹‹å‡º
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    // å¦å‰‡åŒ…è£æˆ internal éŒ¯èª¤
    throw new functions.https.HttpsError(
      "internal", 
      error.message || "ç™»å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œé‡è©¦"
    );
  }
});

// ä¿®å¾©ï¼šchangePassword å‡½æ•¸ä¹Ÿéœ€è¦é¡ä¼¼çš„æ‰‹æ©Ÿè™Ÿè™•ç†
exports.changePassword = functions.https.onCall(async (data, context) => {
  const { phoneNumber, currentPassword, newPassword } = data;
  
  if (!phoneNumber || !currentPassword || !newPassword) {
    throw new functions.https.HttpsError("invalid-argument", "è«‹æä¾›æ‰‹æ©Ÿè™Ÿç¢¼ã€ç•¶å‰å¯†ç¢¼å’Œæ–°å¯†ç¢¼");
  }
  
  // é©—è­‰æ–°å¯†ç¢¼é•·åº¦
  if (newPassword.length < 8) {
    throw new functions.https.HttpsError("invalid-argument", "æ–°å¯†ç¢¼é•·åº¦è‡³å°‘éœ€è¦8å€‹å­—ç¬¦");
  }
  
  // é©—è­‰æ–°å¯†ç¢¼å¼·åº¦ï¼ˆè‡³å°‘åŒ…å«è‹±æ–‡å’Œæ•¸å­—ï¼‰
  const hasLetter = /[a-zA-Z]/.test(newPassword);
  const hasNumber = /[0-9]/.test(newPassword);
  
  if (!hasLetter || !hasNumber) {
    throw new functions.https.HttpsError("invalid-argument", "æ–°å¯†ç¢¼å¿…é ˆåŒ…å«è‹±æ–‡å­—æ¯å’Œæ•¸å­—");
  }
  
  try {
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    const phoneVariants = [
      normalizedPhone,
      `0${normalizedPhone}`,
      `60${normalizedPhone}`,
      phoneNumber
    ];
    
    let userDoc = null;
    
    // å˜—è©¦æ¯ç¨®æ ¼å¼
    for (const variant of phoneVariants) {
      const usersSnap = await admin.firestore().collection("users")
        .where("basicInfo.phoneNumber", "==", variant)
        .limit(1)
        .get();
      
      if (!usersSnap.empty) {
        userDoc = usersSnap.docs[0];
        break;
      }
    }
    
    if (!userDoc) {
      throw new functions.https.HttpsError("not-found", "æŸ¥ç„¡æ­¤æ‰‹æ©Ÿè™Ÿç¢¼");
    }
    
    const userData = userDoc.data();
    
    // é©—è­‰ç•¶å‰å¯†ç¢¼
    const passwordSalt = userData.basicInfo.passwordSalt || userData.basicInfo.pinSalt;
    const currentPasswordHash = crypto.createHash("sha256").update(currentPassword + passwordSalt).digest("hex");
    
    const storedHash = userData.basicInfo.passwordHash || userData.basicInfo.pinHash;
    if (currentPasswordHash !== storedHash) {
      throw new functions.https.HttpsError("permission-denied", "ç•¶å‰å¯†ç¢¼éŒ¯èª¤");
    }
    
    // ç”Ÿæˆæ–°çš„å¯†ç¢¼ hashï¼ˆä½¿ç”¨ç›¸åŒçš„ saltï¼‰
    const newPasswordHash = crypto.createHash("sha256").update(newPassword + passwordSalt).digest("hex");
    
    // æ›´æ–° Firestore
    await userDoc.ref.update({
      "basicInfo.passwordHash": newPasswordHash,
      "basicInfo.pinHash": newPasswordHash,
      "basicInfo.passwordSalt": passwordSalt,
      "basicInfo.pinSalt": passwordSalt
    });
    
    console.log(`[changePassword] Password changed for ${phoneNumber}`);
    return { success: true, message: "å¯†ç¢¼ä¿®æ”¹æˆåŠŸ" };
    
  } catch (error) {
    console.error("[changePassword] Error:", error);
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError("internal", `ä¿®æ”¹å¯†ç¢¼å¤±æ•—ï¼š${error.message}`);
  }
});

function getRedirectUrl(roles) {
  console.log(`[getRedirectUrl] Checking roles:`, JSON.stringify(roles));
  if (!roles || !Array.isArray(roles)) return "../home/index.html";
  
  if (roles.includes("super_admin") || roles.includes("super admin")) return "../admin/admin-dashboard.html";
  if (roles.includes("manager")) return "../manager/admin-manage-users.html";
  if (roles.includes("merchant")) return "../merchant/merchant-dashboard.html";
  if (roles.includes("seller")) return "../seller/seller-dashboard.html";
  if (roles.includes("customer")) return "../customer/consume.html";
  
  console.log(`[getRedirectUrl] No role matched, returning default`);
  return "../home/index.html";
}

exports.loginAndRedirect = functions.https.onCall(async (data, context) => {
  const userUid = context.auth ? context.auth.uid : null;
  console.log(`[loginAndRedirect] User UID from context: ${userUid}`);
  
  const { phoneNumber } = data;
  
  let userSnap;
  if (userUid) {
    userSnap = await admin.firestore().collection("users").where("authUid", "==", userUid).limit(1).get();
  }
  
  if ((!userSnap || userSnap.empty) && phoneNumber) {
    console.log(`[loginAndRedirect] Fallback to phoneNumber query: ${phoneNumber}`);
    userSnap = await admin.firestore().collection("users")
      .where("basicInfo.phoneNumber", "==", phoneNumber)
      .limit(1)
      .get();
  }
  
  console.log(`[loginAndRedirect] Query result: ${userSnap && !userSnap.empty ? 'found' : 'empty'}`);
  if (!userSnap || userSnap.empty) throw new functions.https.HttpsError("not-found", "æ‰¾ä¸åˆ°ä½¿ç”¨è€…è³‡æ–™ã€‚");
  
  const userData = userSnap.docs[0].data();
  return {
    redirectUrl: getRedirectUrl(userData.roles),
    chineseName: userData.basicInfo && userData.basicInfo.chineseName ? userData.basicInfo.chineseName : "",
    roles: userData.roles,
    identityTag: userData.identityTag || "",
  };
});

exports.getManagers = functions.https.onCall(async (data, context) => {
  try {
    const managersSnap = await admin.firestore().collection("managers").get();
    const managers = [];

    managersSnap.forEach(doc => {
      managers.push({
        id: doc.id,
        ...doc.data()
      });
    });

    return { managers };
  } catch (error) {
    console.error("Error fetching managers:", error);
    throw new functions.https.HttpsError("internal", "Unable to fetch managers.");
  }
});

// å°å‡º Firestore è³‡æ–™çš„ Cloud Function
exports.exportFirestoreData = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, POST');
  res.set('Access-Control-Allow-Headers', 'Content-Type');
  
  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }
  
  try {
    console.log('ğŸš€ é–‹å§‹å°å‡º Firestore è³‡æ–™...');
    
    const exportData = {};
    const collections = await admin.firestore().listCollections();
    
    for (const collection of collections) {
      console.log(`ğŸ“ å°å‡ºé›†åˆ: ${collection.id}`);
      const snapshot = await collection.get();
      exportData[collection.id] = {};
      
      for (const doc of snapshot.docs) {
        exportData[collection.id][doc.id] = doc.data();
        
        const subcollections = await doc.ref.listCollections();
        if (subcollections.length > 0) {
          exportData[collection.id][doc.id]._subcollections = {};
          
          for (const subcol of subcollections) {
            const subSnapshot = await subcol.get();
            exportData[collection.id][doc.id]._subcollections[subcol.id] = {};
            
            subSnapshot.docs.forEach(subDoc => {
              exportData[collection.id][doc.id]._subcollections[subcol.id][subDoc.id] = subDoc.data();
            });
          }
        }
      }
      
      console.log(`  âœ… ${collection.id}: ${snapshot.size} å€‹æ–‡æª”`);
    }
    
    console.log('âœ… å°å‡ºå®Œæˆï¼');
    
    res.status(200).json({
      success: true,
      exportDate: new Date().toISOString(),
      data: exportData
    });
    
  } catch (error) {
    console.error('âŒ å°å‡ºå¤±æ•—:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});
```

# functions\admin.js
```
const admin = require('firebase-admin');
const functions = require('firebase-functions');
const crypto = require('crypto');

function getDb() {
  return admin.firestore();
}

function sha256(str) {
  return crypto.createHash("sha256").update(str).digest("hex");
}

// ========== OTP ç›¸å…³å‡½æ•° ==========

exports.sendOtpToPhone = functions.https.onCall(async (data, context) => {
  const { phoneNumber, pinCode } = data;
  if (!phoneNumber || !pinCode) throw new functions.https.HttpsError("invalid-argument", "ç¼ºå°‘å‚æ•°");

  const usersSnap = await getDb().collection("users").where("basicInfo.phoneNumber", "==", phoneNumber).get();
  if (usersSnap.empty) throw new functions.https.HttpsError("not-found", "ç”¨æˆ·ä¸å­˜åœ¨");
  const userDoc = usersSnap.docs[0];
  const user = userDoc.data();

  const pinSalt = user.basicInfo && user.basicInfo.pinSalt ? user.basicInfo.pinSalt : undefined;
  const pinHash = user.basicInfo && user.basicInfo.pinHash ? user.basicInfo.pinHash : undefined;
  if (!pinSalt || !pinHash) throw new functions.https.HttpsError("failed-precondition", "PIN èµ„æ–™ç¼ºå¤±");
  if (sha256(pinCode + pinSalt) !== pinHash) throw new functions.https.HttpsError("permission-denied", "PIN éªŒè¯å¤±è´¥");

  const otpCode = Math.floor(100000 + Math.random() * 900000).toString();
  const otpCodeHash = sha256(otpCode);
  const sessionId = crypto.randomUUID();
  const expiresAt = Date.now() + 5 * 60 * 1000;

  await getDb().collection("otp_collection").doc(sessionId).set({
    sessionId,
    phoneNumber,
    otpCodeHash,
    expiresAt,
    attempts: 0,
    authUid: user.authUid
  });

  console.log(`[OTP] Send to ${phoneNumber}: ${otpCode}`);
  return { sessionId };
});

exports.verifyOtpCode = functions.https.onCall(async (data, context) => {
  const { sessionId, otpCode } = data;
  if (!sessionId || !otpCode) throw new functions.https.HttpsError("invalid-argument", "ç¼ºå°‘å‚æ•°");

  const otpDocRef = getDb().collection("otp_collection").doc(sessionId);
  const otpDocSnap = await otpDocRef.get();
  if (!otpDocSnap.exists) throw new functions.https.HttpsError("not-found", "OTP session ä¸å­˜åœ¨");
  const otpData = otpDocSnap.data();
  if (!otpData) throw new functions.https.HttpsError("not-found", "OTP èµ„æ–™ä¸å­˜åœ¨");
  if (Date.now() > otpData.expiresAt) throw new functions.https.HttpsError("deadline-exceeded", "OTP å·²è¿‡æœŸ");
  if (sha256(otpCode) !== otpData.otpCodeHash) {
    await otpDocRef.update({ attempts: (otpData.attempts || 0) + 1 });
    throw new functions.https.HttpsError("permission-denied", "OTP éªŒè¯å¤±è´¥");
  }
  const customToken = await admin.auth().createCustomToken(otpData.authUid);
  await otpDocRef.delete();
  return { customToken };
});

// ========== ç®¡ç†å‘˜æ£€æŸ¥ä¸åˆå§‹åŒ– ==========

exports.checkAdminExists = functions.https.onCall(async (data, context) => {
  try {
    const snapshot = await getDb().collection('users')
      .where('roles', 'array-contains', 'super_admin')
      .limit(1)
      .get();
    const exists = !snapshot.empty;
    return { exists };
  } catch (error) {
    throw new functions.https.HttpsError("internal", "æ£€æŸ¥ç®¡ç†å‘˜å¤±è´¥");
  }
});

exports.createInitialAdmin = functions.https.onCall(async (data, context) => {
  const actualData = data.data || data;
  const { 
    phoneNumber, 
    englishName, 
    chineseName, 
    email,
    identityTag,
    department,
    password,
    includeMerchant,
    projectInfo 
  } = actualData;

  console.log('[createInitialAdmin] Received data:', { 
    phoneNumber, 
    englishName, 
    chineseName, 
    email,
    identityTag,
    department,
    hasPassword: !!password,
    includeMerchant,
    hasProjectInfo: !!projectInfo 
  });

  // éªŒè¯å¿…å¡«å­—æ®µ
  if (!phoneNumber || !englishName || !email || !password || typeof phoneNumber !== 'string') {
    throw new functions.https.HttpsError('invalid-argument', 'ç¼ºå°‘æ‰‹æœºå·ç ã€è‹±æ–‡å§“åã€é‚®ç®±æˆ–å¯†ç ');
  }

  // éªŒè¯èº«ä»½æ ‡ç­¾ - åªå…è®¸ staff å’Œ teacher
  const validIdentityTags = ['staff', 'teacher'];
  if (!identityTag || !validIdentityTags.includes(identityTag)) {
    throw new functions.https.HttpsError('invalid-argument', 'è¯·é€‰æ‹©æœ‰æ•ˆçš„èº«ä»½æ ‡ç­¾ (staff æˆ– teacher)');
  }

  // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¶…çº§ç®¡ç†å‘˜
  const check = await getDb().collection('users')
    .where('roles', 'array-contains', 'super_admin')
    .limit(1)
    .get();
  
  if (!check.empty) {
    throw new functions.https.HttpsError('already-exists', 'å·²æœ‰ç®¡ç†å‘˜,æ— æ³•é‡å¤åˆå§‹åŒ–');
  }

  // å¤„ç†å›½é™…ç”µè¯å·ç æ ¼å¼
  const internationalPhone = phoneNumber.startsWith('+')
    ? phoneNumber
    : `+${phoneNumber.replace(/^0/, '60')}`;

  let userRecord;
  try {
    userRecord = await admin.auth().getUserByPhoneNumber(internationalPhone);
    userRecord = await admin.auth().updateUser(userRecord.uid, {
      displayName: englishName,
      email: email
    });
  } catch (error) {
    if (error.code === 'auth/user-not-found') {
      userRecord = await admin.auth().createUser({
        phoneNumber: internationalPhone,
        displayName: englishName,
        email: email
      });
    } else {
      throw error;
    }
  }

  // ç”Ÿæˆæ–‡æ¡£ID
  const docId = `usr_${crypto.randomUUID()}`;
  
  // ç”Ÿæˆå¯†ç  hash å’Œ salt
  const passwordSalt = crypto.randomBytes(16).toString('hex');
  const passwordHash = sha256(password + passwordSalt);

  // æ£€æŸ¥æ–‡æ¡£æ˜¯å¦å·²å­˜åœ¨
  const existingUserDoc = await getDb().collection('users').doc(docId).get();
  if (existingUserDoc.exists) {
    throw new functions.https.HttpsError('already-exists', 'ç”¨æˆ·æ–‡ä»¶å·²å­˜åœ¨');
  }

  // æ„å»ºè§’è‰²æ•°ç»„ï¼šsuper_admin + seller + customer + (å¯é€‰)merchant
  const roles = ['super_admin', 'seller', 'customer'];
  if (includeMerchant) {
    roles.push('merchant');
  }

  console.log('[createInitialAdmin] Roles assigned:', roles);

  // æ„å»º identityInfo åŸºäº identityTag
  let identityInfo = {};
  let superAdminId = 'SA001';
  
  switch (identityTag) {
    case 'staff':
      identityInfo = {
        staffId: superAdminId,
        position: 'super_admin',
        department: department || 'ç³»ç»Ÿç®¡ç†éƒ¨'
      };
      break;
    case 'teacher':
      identityInfo = {
        teacherId: superAdminId,
        department: department || 'ç³»ç»Ÿç®¡ç†éƒ¨'
      };
      break;
  }

  // è·å–æ€»èµ„æœ¬
  const totalCapital = projectInfo?.settings?.totalCapital || 2000000;

  // æ„å»º roleSpecificData - åŒ…å«æ‰€æœ‰è§’è‰²çš„æ•°æ®
  const roleSpecificData = {
    super_admin: {
      superAdminId: superAdminId,
      totalCapitalManaged: totalCapital,
      allocatedCapital: 0,
      availableCapital: totalCapital,
      totalManagersAssigned: 0,
      allocationHistory: {
        totalAllocations: 0,
        lastAllocationAt: null,
        totalReclaimed: 0
      }
    },
    seller: {
      availablePoints: 0,
      currentSalesAmount: 0,
      totalPointsSold: 0,
      capitalSource: {
        assignedBy: 'self',
        assignedAt: new Date(),
        allocationId: null
      }
    },
    customer: {
      currentBalance: 0,
      totalPointsPurchased: 0,
      totalPointsConsumed: 0
    }
  };

  // å¦‚æœåŒ…å« merchant è§’è‰²ï¼Œæ·»åŠ  merchant æ•°æ®
  if (includeMerchant) {
    roleSpecificData.merchant = {
      totalReceivedPoints: 0,
      monthlyReceivedPoints: 0
    };
  }

  // åˆ›å»ºç”¨æˆ·æ–‡æ¡£ - å®Œå…¨ç¬¦åˆæ–°æ¶æ„
  const userDoc = {
    userId: docId,
    authUid: userRecord.uid,
    roles: roles,
    identityTag: identityTag,
    basicInfo: {
      phoneNumber: phoneNumber,
      englishName: englishName,
      chineseName: chineseName || '',
      email: email,
      pinHash: passwordHash,
      pinSalt: passwordSalt,
      passwordHash: passwordHash,
      passwordSalt: passwordSalt,
      isPhoneVerified: true
    },
    identityInfo: identityInfo,
    roleSpecificData: roleSpecificData,
    activityData: {
      joinedAt: new Date(),
      lastActiveAt: new Date(),
      participationStatus: 'active'
    },
    accountStatus: {
      status: 'active',
      mustChangePassword: false,
      createdAt: new Date(),
      updatedAt: new Date()
    },
    metadata: {
      registrationSource: 'initial_admin',
      operatorUid: context && context.auth && context.auth.uid ? context.auth.uid : 'system',
      notes: `ç³»ç»Ÿåˆå§‹åŒ–è¶…çº§ç®¡ç†å‘˜ - è§’è‰²: ${roles.join(', ')}${department ? ' - éƒ¨é—¨: ' + department : ''}`
    }
  };

  // å¦‚æœåŒ…å« merchantï¼Œæ·»åŠ  businessInfo
  if (includeMerchant) {
    userDoc.businessInfo = {
      businessType: 'general',
      operatingHours: {
        'zh-CN': 'ä¹‰å–ä¼šæœŸé—´è¥ä¸š',
        'en': 'Open during charity fair'
      },
      description: {
        'zh-CN': `${department || 'ç®¡ç†å‘˜'}æ¡£å£`,
        'en': `${department || 'Administrator'} stall`
      }
    };
  }

  // ä¿å­˜ç”¨æˆ·æ–‡æ¡£
  await getDb().collection('users').doc(docId).set(userDoc);

  // ä¿å­˜åˆ° admin_uids é›†åˆ
  await getDb().collection('admin_uids').doc(userRecord.uid).set({
    uid: userRecord.uid,
    englishName: englishName,
    chineseName: chineseName || '',
    email: email,
    department: department || '',
    permissions: ['all'],
    createdAt: new Date()
  });

  // ä¿å­˜é¡¹ç›®é…ç½®
  if (projectInfo) {
    try {
      console.log('[createInitialAdmin] Saving project info:', projectInfo);
      await getDb().collection('system_config').doc('project_info').set(projectInfo);
      console.log('[createInitialAdmin] Project info saved successfully');
    } catch (error) {
      console.error('[createInitialAdmin] Error saving project info:', error);
    }
  }

  // åˆå§‹åŒ–å…¨å±€è®¾ç½®
  await getDb().collection('system_config').doc('global_settings').set({
    defaultLanguage: 'zh-CN',
    supportedLanguages: ['zh-CN', 'en'],
    timezone: 'Asia/Kuala_Lumpur',
    currency: 'MYR',
    version: '4.2.0',
    features: {
      multiLanguage: true,
      otpVerification: true,
      transactionLogging: true,
      roleBasedPermissions: true,
      multiRoleSupport: true,
      capitalAllocationTracking: true
    },
    otp: {
      enabled: true,
      expirySeconds: 300,
      maxAttempts: 5,
      provider: 'twilio'
    },
    pin: {
      minLength: 6,
      maxLength: 6,
      hashAlgorithm: 'SHA-256',
      requireOtpVerification: true
    },
    nameFields: {
      englishName: {
        required: true,
        description: {
          'zh-CN': 'è‹±æ–‡åå­—æˆ–æ‹¼éŸ³åå­—(å¿…å¡«)',
          'en': 'English name or romanized name (required)'
        }
      },
      chineseName: {
        required: false,
        description: {
          'zh-CN': 'ä¸­æ–‡åå­—(é€‰å¡«)',
          'en': 'Chinese name (optional)'
        }
      }
    }
  });

  console.log('[createInitialAdmin] Super admin created successfully:', {
    userId: docId,
    authUid: userRecord.uid,
    englishName: englishName,
    identityTag: identityTag,
    department: department,
    roles: roles
  });

  return {
    success: true,
    userId: docId,
    authUid: userRecord.uid,
    roles: roles,
    department: department || '',
    message: 'ç®¡ç†å‘˜åˆ›å»ºæˆåŠŸ,è¯·ä½¿ç”¨æ‰‹æœºå· + å¯†ç ç™»å½•'
  };
});

// ========== é¡¹ç›®é…ç½®ç®¡ç† ==========

exports.setProjectInfo = functions.https.onCall(async (data, context) => {
  const { projectInfo } = data;
  if (!projectInfo) {
    throw new functions.https.HttpsError("invalid-argument", "ç¼ºå°‘ projectInfo èµ„æ–™");
  }

  try {
    await getDb().collection("system_config").doc("project_info").set(projectInfo);
    return { success: true, message: "é¡¹ç›®é…ç½®å·²æˆåŠŸä¿å­˜" };
  } catch (error) {
    console.error("ä¿å­˜é¡¹ç›®é…ç½®å¤±è´¥:", error);
    throw new functions.https.HttpsError("internal", "ä¿å­˜é¡¹ç›®é…ç½®å¤±è´¥", error.message);
  }
});

exports.getTotalCapital = functions.https.onCall(async (data, context) => {
  try {
    const projectInfoDoc = await getDb().collection('system_config').doc('project_info').get();
    
    if (!projectInfoDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'æ‰¾ä¸åˆ°ä¸“æ¡ˆé…ç½®');
    }
    
    const projectInfo = projectInfoDoc.data();
    const totalCapital = projectInfo.settings?.totalCapital || 0;
    const statistics = projectInfo.statistics || {};
    const assignedCapital = statistics.assignedCapital || 0;
    const availableCapital = statistics.availableCapital || totalCapital;
    
    console.log('[getTotalCapital] Capital info:', { totalCapital, assignedCapital, availableCapital });
    
    return { 
      totalCapital,
      assignedCapital,
      availableCapital
    };
  } catch (error) {
    console.error('[getTotalCapital] Error:', error);
    throw new functions.https.HttpsError('internal', 'å–å¾—æ€»èµ„æœ¬å¤±è´¥', error.message);
  }
});

exports.getAssignedCapitalSum = functions.https.onCall(async (data, context) => {
  try {
    const managersSnap = await getDb().collection('users')
      .where('roles', 'array-contains', 'manager')
      .get();
    
    let assignedSum = 0;
    managersSnap.forEach(doc => {
      const managerData = doc.data();
      assignedSum += managerData.roleSpecificData?.manager?.assignedCapital || 0;
    });
    
    console.log('[getAssignedCapitalSum] Assigned sum:', assignedSum);
    return { assignedSum };
  } catch (error) {
    console.error('[getAssignedCapitalSum] Error:', error);
    throw new functions.https.HttpsError('internal', 'å–å¾—åˆ†é…æ€»å’Œå¤±è´¥', error.message);
  }
});

// ========== Manager ç®¡ç† ==========

exports.createManager = functions.https.onCall(async (data, context) => {
  console.log('[createManager] Received request, context.auth:', context.auth ? context.auth.uid : 'null');
  
  const actualData = data.data || data;
  const callerUid = context.auth ? context.auth.uid : actualData.callerUid;
  
  console.log('[createManager] Caller UID:', callerUid);
  
  if (!callerUid) {
    throw new functions.https.HttpsError('unauthenticated', 'å¿…é¡»ç™»å…¥æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ');
  }
  
  // éªŒè¯æƒé™
  try {
    const userQuery = await getDb().collection('users')
      .where('authUid', '==', callerUid)
      .limit(1)
      .get();
    
    let hasPermission = false;
    
    if (!userQuery.empty) {
      const userData = userQuery.docs[0].data();
      console.log('[createManager] Found user by authUid:', { 
        docId: userQuery.docs[0].id, 
        roles: userData.roles 
      });
      hasPermission = userData.roles && userData.roles.includes('super_admin');
    } else {
      const directDoc = await getDb().collection('users').doc(callerUid).get();
      if (directDoc.exists) {
        const userData = directDoc.data();
        console.log('[createManager] Found user by docId:', { 
          docId: directDoc.id, 
          roles: userData.roles 
        });
        hasPermission = userData.roles && userData.roles.includes('super_admin');
      }
    }
    
    if (!hasPermission) {
      console.log('[createManager] Permission denied: User is not super_admin');
      throw new functions.https.HttpsError('permission-denied', 'åªæœ‰è¶…çº§ç®¡ç†å‘˜å¯ä»¥å»ºç«‹ Manager');
    }
    
    console.log('[createManager] Permission check passed');
  } catch (error) {
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    console.error('[createManager] Permission check error:', error);
    throw new functions.https.HttpsError('internal', 'æƒé™éªŒè¯å¤±è´¥: ' + error.message);
  }
  
  const { phoneNumber, password, englishName, chineseName, identityTag, assignedCapital } = actualData;
  
  console.log('[createManager] Creating manager:', { 
    phoneNumber, 
    englishName, 
    chineseName, 
    identityTag,
    assignedCapital 
  });
  
  // éªŒè¯å¿…è¦æ ä½
  if (!phoneNumber || !password || !englishName || assignedCapital === undefined) {
    throw new functions.https.HttpsError('invalid-argument', 'ç¼ºå°‘å¿…è¦æ ä½');
  }
  
  // éªŒè¯å¯†ç å¼ºåº¦
  if (password.length < 8) {
    throw new functions.https.HttpsError('invalid-argument', 'å¯†ç è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦');
  }
  
  if (!/[a-zA-Z]/.test(password) || !/\d/.test(password)) {
    throw new functions.https.HttpsError('invalid-argument', 'å¯†ç å¿…é¡»åŒ…å«è‹±æ–‡å­—æ¯å’Œæ•°å­—');
  }
  
  // éªŒè¯èº«ä»½æ ‡ç­¾ (manager å¿…é¡»æœ‰èº«ä»½æ ‡ç­¾)
  const validIdentityTags = ['staff', 'teacher'];
  if (!identityTag || !validIdentityTags.includes(identityTag)) {
    throw new functions.https.HttpsError('invalid-argument', 'Manager å¿…é¡»é€‰æ‹©æœ‰æ•ˆçš„èº«ä»½æ ‡ç­¾ (staff æˆ– teacher)');
  }
  
  try {
    // æ£€æŸ¥æ‰‹æœºå·ç æ˜¯å¦å·²å­˜åœ¨
    const existingUserSnap = await getDb().collection('users')
      .where('basicInfo.phoneNumber', '==', phoneNumber)
      .limit(1)
      .get();
    
    if (!existingUserSnap.empty) {
      throw new functions.https.HttpsError('already-exists', 'æ­¤æ‰‹æœºå·ç å·²è¢«ä½¿ç”¨');
    }
    
    // éªŒè¯åˆ†é…é¢åº¦æ˜¯å¦è¶…è¿‡å¯ç”¨é¢åº¦
    const projectInfoRef = getDb().collection('system_config').doc('project_info');
    const projectInfoDoc = await projectInfoRef.get();
    const projectInfo = projectInfoDoc.data();
    const totalCapital = projectInfo.settings?.totalCapital || 0;
    
    const managersSnap = await getDb().collection('users')
      .where('roles', 'array-contains', 'manager')
      .get();
    
    let assignedSum = 0;
    managersSnap.forEach(doc => {
      const managerData = doc.data();
      assignedSum += managerData.roleSpecificData?.manager?.assignedCapital || 0;
    });
    
    if (assignedCapital + assignedSum > totalCapital) {
      throw new functions.https.HttpsError(
        'failed-precondition', 
        `åˆ†é…é¢åº¦è¶…è¿‡å¯ç”¨é¢åº¦,å¯ç”¨: ${totalCapital - assignedSum}`
      );
    }
    
    // ç”Ÿæˆ password hash å’Œ salt
    const passwordSalt = crypto.randomBytes(16).toString('hex');
    const passwordHash = sha256(password + passwordSalt);
    
    // å»ºç«‹ Auth ç”¨æˆ·
    const authUid = `phone_60${phoneNumber.replace(/^0/, "")}`;
    let userRecord;
    
    try {
      userRecord = await admin.auth().createUser({
        uid: authUid,
        displayName: englishName,
        disabled: false
      });
    } catch (authError) {
      if (authError.code === 'auth/uid-already-exists') {
        userRecord = await admin.auth().getUser(authUid);
      } else {
        throw authError;
      }
    }
    
    // ç”Ÿæˆ Manager ID
    const managerIdNum = managersSnap.size + 1;
    const managerId = `M${managerIdNum.toString().padStart(3, '0')}`;
    
    // æ„å»º identityInfo
    let identityInfo = {};
    switch (identityTag) {
      case 'staff':
        identityInfo = {
          staffId: managerId,
          position: 'manager'
        };
        break;
      case 'teacher':
        identityInfo = {
          teacherId: managerId,
          department: 'æ´»åŠ¨ç®¡ç†'
        };
        break;
    }
    
    // å»ºç«‹ Firestore æ–‡æ¡£ - å®Œå…¨ç¬¦åˆæ–°æ¶æ„
    const docId = `usr_${crypto.randomUUID()}`;
    await getDb().collection('users').doc(docId).set({
      userId: docId,
      authUid: userRecord.uid,
      roles: ['manager'],
      identityTag: identityTag,
      basicInfo: {
        phoneNumber: phoneNumber,
        englishName: englishName,
        chineseName: chineseName || '',
        pinHash: passwordHash,
        pinSalt: passwordSalt,
        passwordHash: passwordHash,
        passwordSalt: passwordSalt,
        isPhoneVerified: true
      },
      identityInfo: identityInfo,
      roleSpecificData: {
        manager: {
          managerId: managerId,
          assignedCapital: assignedCapital,
          allocatedToSellers: 0,
          availableCapital: assignedCapital,
          totalSellersManaged: 0,  // åŠ¨æ€è®¡ç®—,ä¸å­˜å‚¨æ•°ç»„
          performance: {
            totalPointsSoldBySellers: 0,
            totalRevenue: 0,
            utilizationRate: 0
          },
          allocationHistory: {
            totalAllocations: 0,
            lastAllocationAt: null,
            totalReclaimed: 0
          },
          capitalSource: {
            assignedBy: callerUid,
            assignedAt: new Date(),
            allocationId: null  // åç»­åˆ›å»ºåˆ†é…è®°å½•æ—¶æ›´æ–°
          }
        }
      },
      activityData: {
        joinedAt: new Date(),
        lastActiveAt: new Date(),
        participationStatus: 'active'
      },
      accountStatus: {
        status: 'active',
        mustChangePassword: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      metadata: {
        registrationSource: 'admin_create',
        operatorUid: callerUid,
        createdBy: callerUid
      }
    });
    
    // æ›´æ–°ç»Ÿè®¡èµ„æ–™
    const newAssignedSum = assignedSum + assignedCapital;
    const newManagerCount = managersSnap.size + 1;
    
    await projectInfoRef.update({
      'statistics.totalManagers': newManagerCount,
      'statistics.assignedCapital': newAssignedSum,
      'statistics.availableCapital': totalCapital - newAssignedSum
    });
    
    console.log('[createManager] Manager created successfully:', docId);
    console.log('[createManager] Updated statistics:', { 
      totalManagers: newManagerCount, 
      assignedCapital: newAssignedSum,
      availableCapital: totalCapital - newAssignedSum
    });
    
    return {
      success: true,
      userId: docId,
      authUid: userRecord.uid,
      managerId: managerId,
      message: 'ç®¡ç†å‘˜å»ºç«‹æˆåŠŸ'
    };
  } catch (error) {
    console.error('[createManager] Error:', error);
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError('internal', error.message || 'å»ºç«‹ç®¡ç†å‘˜å¤±è´¥');
  }
});
```

# src\contexts\AuthContext.jsx
```
// src/contexts/AuthContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import { auth } from '../config/firebase';
import { onAuthStateChanged } from 'firebase/auth';
import { authService } from '../services/authService';
import { useEvent } from './EventContext';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null);
  const [userProfile, setUserProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const { organizationId, eventId } = useEvent();

  // ç›‘å¬ Firebase Auth çŠ¶æ€å˜åŒ–
  useEffect(() => {
    if (!organizationId || !eventId) {
      console.warn('[AuthContext] No organizationId or eventId');
      setLoading(false);
      return;
    }

    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      console.log('[AuthContext] Auth state changed:', user ? user.uid : 'no user');
      
      if (user && !user.isAnonymous) {
        setCurrentUser(user);
        
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ç”¨æˆ·èµ„æ–™ï¼ˆä»ç™»å½•æ—¶è·å¾—ï¼‰
        if (!userProfile) {
          // å¦‚æœæ²¡æœ‰ï¼Œå°è¯•ä» Firestore åŠ è½½ï¼ˆéœ€è¦æ­£ç¡®çš„æƒé™ï¼‰
          try {
            const profile = await authService.getUserProfile(
              user.uid, 
              organizationId, 
              eventId
            );
            setUserProfile(profile);
            console.log('[AuthContext] User profile loaded from Firestore:', profile);
          } catch (err) {
            console.error('[AuthContext] Failed to load user profile:', err);
            // ä¸è®¾ç½®ä¸º nullï¼Œä¿ç•™å·²æœ‰çš„ userProfile
          }
        }
      } else {
        setCurrentUser(null);
        setUserProfile(null);
      }
      
      setLoading(false);
    });

    return () => unsubscribe();
  }, [organizationId, eventId, userProfile]);

  // ç™»å…¥å‡½æ•°
  const login = async (phoneNumber, password) => {
    try {
      setError(null);
      setLoading(true);
      
      console.log('[AuthContext] Login called');
      
      if (!organizationId || !eventId) {
        throw new Error('æ— æ³•è·å–ç»„ç»‡æˆ–æ´»åŠ¨ä¿¡æ¯ï¼Œè¯·é‡æ–°åŠ è½½é¡µé¢');
      }
      
      const result = await authService.loginWithPin(phoneNumber, password, organizationId, eventId);
      
      // ğŸ”¥ å¦‚æœç™»å½•è¿”å›äº†ç”¨æˆ·èµ„æ–™ï¼Œç›´æ¥è®¾ç½®
      if (result.userProfile) {
        setUserProfile(result.userProfile);
        console.log('[AuthContext] User profile set from login result:', result.userProfile);
      }
      
      return result;
    } catch (err) {
      console.error('[AuthContext] Login error:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    try {
      await authService.logout();
      setCurrentUser(null);
      setUserProfile(null);
    } catch (err) {
      console.error('[AuthContext] Logout error:', err);
      throw err;
    }
  };

  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ç‰¹å®šè§’è‰²
  const hasRole = (role) => {
    if (!userProfile || !userProfile.roles) return false;
    return userProfile.roles.includes(role);
  };

  // è·å–ç”¨æˆ·ä¸»è¦è§’è‰²ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„è§’è‰²ï¼‰
  const getPrimaryRole = () => {
    if (!userProfile || !userProfile.roles) return null;
    
    const rolePriority = [
      'platform_admin',
      'org_admin', 
      'event_manager',
      'manager',
      'merchant',
      'seller',
      'customer'
    ];
    
    for (const role of rolePriority) {
      if (userProfile.roles.includes(role)) {
        return role;
      }
    }
    
    return null;
  };

  const value = {
    currentUser,
    userProfile,
    loading,
    error,
    login,
    logout,
    hasRole,
    getPrimaryRole,
    isAuthenticated: !!currentUser && !currentUser.isAnonymous
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
```
# src\services\authService.js
```
// src/services/authService.js
import { auth, db, functions } from '../config/firebase';
import { signInWithCustomToken, signOut } from 'firebase/auth';
import { httpsCallable } from 'firebase/functions';
import { query, where, collection, getDocs } from 'firebase/firestore';

/**
 * ğŸ”¥ ä¿®å¾©ï¼šæ¨™æº–åŒ–æ‰‹æ©Ÿè™Ÿç¢¼æ ¼å¼
 */
function normalizePhone(phoneNumber) {
  if (!phoneNumber) return null;
  
  // ç§»é™¤æ‰€æœ‰ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦
  let cleaned = phoneNumber.trim().replace(/[\s\-\(\)]/g, '');
  
  // å¦‚æœä»¥ +60 æˆ– 60 é–‹é ­ï¼Œç§»é™¤å®ƒ
  if (cleaned.startsWith('+60')) {
    cleaned = cleaned.substring(3);
  } else if (cleaned.startsWith('60')) {
    cleaned = cleaned.substring(2);
  }
  
  // å¦‚æœä»¥ 0 é–‹é ­ï¼Œç§»é™¤å®ƒ
  if (cleaned.startsWith('0')) {
    cleaned = cleaned.substring(1);
  }
  
  // é©—è­‰æ ¼å¼ï¼šæ‡‰è©²æ˜¯ 1 é–‹é ­ï¼Œå¾Œæ¥ 8-9 ä½æ•¸å­—ï¼ˆé¦¬ä¾†è¥¿äºæ‰‹æ©Ÿè™Ÿï¼‰
  if (!/^1\d{8,9}$/.test(cleaned)) {
    return null;
  }
  
  // è¿”å›æ¨™æº–æ ¼å¼ï¼š0 + æ•¸å­—ï¼ˆä¾‹å¦‚ï¼š0123456789ï¼‰
  return '0' + cleaned;
}

/**
 * é©—è­‰å¯†ç¢¼å¼·åº¦
 */
function validatePassword(password) {
  if (!password || password.length < 8) return false;
  const hasLetter = /[a-zA-Z]/.test(password);
  const hasNumber = /\d/.test(password);
  return hasLetter && hasNumber;
}

/**
 * ğŸ”¥ ä¿®å¾©ï¼šä½¿ç”¨ PIN ç¢¼ç™»å…¥
 */
async function loginWithPin(phoneNumber, password, organizationId, eventId) {
  try {
    console.log('[authService] Login attempt:', { 
      phoneNumber, 
      organizationId, 
      eventId 
    });
    
    // é©—è­‰åƒæ•¸
    if (!phoneNumber || !password || !organizationId || !eventId) {
      throw new Error('è«‹æä¾›å®Œæ•´çš„ç™»å…¥ä¿¡æ¯');
    }
    
    // æ¨™æº–åŒ–æ‰‹æ©Ÿè™Ÿç¢¼
    const normalized = normalizePhone(phoneNumber);
    if (!normalized) {
      throw new Error('æ‰‹æ©Ÿè™Ÿæ ¼å¼ä¸æ­£ç¢ºï¼Œè«‹è¼¸å…¥ 01 é–‹é ­çš„ 10-11 ä½æ•¸å­—');
    }
    
    console.log('[authService] Normalized phone:', normalized);
    
    // é©—è­‰å¯†ç¢¼
    if (!validatePassword(password)) {
      throw new Error('å¯†ç¢¼è‡³å°‘éœ€è¦ 8 å€‹å­—ç¬¦ï¼Œä¸”å¿…é ˆåŒ…å«è‹±æ–‡å­—æ¯å’Œæ•¸å­—');
    }
    
    // ğŸ”¥ èª¿ç”¨ Cloud Function
    console.log('[authService] Calling Cloud Function...');
    const loginWithPinFn = httpsCallable(functions, 'loginWithPin');
    
    let result;
    try {
      result = await loginWithPinFn({ 
        phoneNumber: normalized, 
        pin: password,
        organizationId,
        eventId
      });
      
      console.log('[authService] Cloud Function response received');
    } catch (fnError) {
      console.error('[authService] Cloud Function error:', {
        code: fnError.code,
        message: fnError.message,
        details: fnError.details
      });
      
      // ğŸ”¥ æ›´è©³ç´°çš„éŒ¯èª¤è™•ç†
      if (fnError.code === 'unavailable') {
        throw new Error('ç„¡æ³•é€£æ¥åˆ°æœå‹™å™¨ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡é€£æ¥æˆ–ç¨å¾Œé‡è©¦');
      }
      
      throw fnError;
    }
    
    const data = result.data;
    console.log('[authService] Response data:', {
      hasCustomToken: !!data?.customToken,
      hasUserProfile: !!data?.userProfile
    });
    
    if (!data?.customToken) {
      console.error('[authService] No custom token in response');
      throw new Error(data?.message || 'ç™»å…¥å¤±æ•—ï¼šæœªæ”¶åˆ°èªè­‰ä»¤ç‰Œ');
    }
    
    // ğŸ”¥ ä½¿ç”¨è‡ªå®šç¾©ä»¤ç‰Œç™»å…¥ Firebase Auth
    console.log('[authService] Signing in with custom token...');
    try {
      await signInWithCustomToken(auth, data.customToken);
      console.log('[authService] Firebase Auth sign-in successful');
    } catch (authError) {
      console.error('[authService] Firebase Auth error:', authError);
      throw new Error('èªè­‰å¤±æ•—ï¼Œè«‹é‡è©¦');
    }
    
    return {
      success: true,
      user: data,
      userProfile: data.userProfile,
      message: 'ç™»å…¥æˆåŠŸ'
    };
    
  } catch (error) {
    console.error('[authService] Login error:', {
      name: error.name,
      code: error.code,
      message: error.message,
      stack: error.stack
    });
    
    // ğŸ”¥ çµ±ä¸€éŒ¯èª¤è™•ç†
    let errorMessage = 'ç™»å…¥å¤±æ•—';
    
    if (error.code === 'not-found') {
      errorMessage = 'æŸ¥ç„¡æ­¤æ‰‹æ©Ÿè™Ÿç¢¼ï¼Œè«‹ç¢ºèªå¾Œé‡è©¦';
    } else if (error.code === 'permission-denied') {
      errorMessage = 'å¯†ç¢¼éŒ¯èª¤ï¼Œè«‹é‡æ–°è¼¸å…¥';
    } else if (error.code === 'invalid-argument') {
      errorMessage = error.message || 'è¼¸å…¥è³‡æ–™æ ¼å¼ä¸æ­£ç¢º';
    } else if (error.code === 'internal') {
      errorMessage = 'æœå‹™å™¨å…§éƒ¨éŒ¯èª¤ï¼Œè«‹ç¨å¾Œé‡è©¦';
    } else if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
      errorMessage = 'ç¶²çµ¡é€£æ¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²çµ¡å¾Œé‡è©¦';
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    throw new Error(errorMessage);
  }
}

/**
 * ç™»å‡º
 */
async function logout() {
  try {
    await signOut(auth);
    console.log('[authService] Logout successful');
  } catch (error) {
    console.error('[authService] Logout error:', error);
    throw error;
  }
}

/**
 * ğŸ”¥ ä¿®å¾©ï¼šæ ¹æ“š authUid ç²å–ç”¨æˆ¶è³‡æ–™
 */
async function getUserProfile(authUid, orgId, eventId) {
  if (!authUid || !orgId || !eventId) {
    throw new Error('getUserProfile requires authUid, orgId, and eventId');
  }

  try {
    const userCollectionPath = `organizations/${orgId}/events/${eventId}/users`;
    console.log('[authService] Querying user from:', userCollectionPath);
    
    const q = query(
      collection(db, userCollectionPath),
      where('authUid', '==', authUid)
    );
    
    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      // ğŸ”¥ å˜—è©¦æŸ¥è©¢å…¶ä»–å¯èƒ½çš„ authUid å­—æ®µ
      const alternativeFields = ['accountStatus.authUid', 'authId', 'authMid'];
      
      for (const field of alternativeFields) {
        const altQ = query(
          collection(db, userCollectionPath),
          where(field, '==', authUid)
        );
        
        const altSnapshot = await getDocs(altQ);
        if (!altSnapshot.empty) {
          console.log(`[authService] Found user with ${field}`);
          const userDoc = altSnapshot.docs[0];
          return {
            id: userDoc.id,
            orgId,
            eventId,
            ...userDoc.data()
          };
        }
      }
      
      console.warn('[authService] No user profile found for authUid:', authUid);
      return null;
    }
    
    const userDoc = querySnapshot.docs[0];
    return {
      id: userDoc.id,
      orgId,
      eventId,
      ...userDoc.data()
    };
  } catch (error) {
    console.error('[authService] Error getting user profile:', error);
    throw error;
  }
}

/**
 * ä¿®æ”¹å¯†ç¢¼
 */
async function changePassword(phoneNumber, currentPassword, newPassword) {
  try {
    const normalized = normalizePhone(phoneNumber);
    if (!normalized) {
      throw new Error('æ‰‹æ©Ÿè™Ÿæ ¼å¼ä¸æ­£ç¢º');
    }

    if (!validatePassword(newPassword)) {
      throw new Error('æ–°å¯†ç¢¼è‡³å°‘éœ€è¦ 8 å€‹å­—ç¬¦ï¼Œä¸”å¿…é ˆåŒ…å«è‹±æ–‡å­—æ¯å’Œæ•¸å­—');
    }

    const changePasswordFn = httpsCallable(functions, 'changePassword');
    const result = await changePasswordFn({
      phoneNumber: normalized,
      currentPassword,
      newPassword
    });

    return result.data;
  } catch (error) {
    console.error('[authService] Change password error:', error);
    throw new Error(error.message || 'ä¿®æ”¹å¯†ç¢¼å¤±æ•—');
  }
}

/**
 * ç™¼é€ OTP
 */
async function sendOtp(phoneNumber, pinCode) {
  try {
    const normalized = normalizePhone(phoneNumber);
    if (!normalized) {
      throw new Error('æ‰‹æ©Ÿè™Ÿæ ¼å¼ä¸æ­£ç¢º');
    }

    const sendOtpFn = httpsCallable(functions, 'sendOtpToPhone');
    const result = await sendOtpFn({
      phoneNumber: normalized,
      pinCode
    });

    return result.data;
  } catch (error) {
    console.error('[authService] Send OTP error:', error);
    throw new Error(error.message || 'ç™¼é€ OTP å¤±æ•—');
  }
}

// å°å‡ºæ‰€æœ‰å‡½æ•¸
export const authService = {
  loginWithPin,
  logout,
  getUserProfile,
  changePassword,
  sendOtp,
  normalizePhone,
  validatePassword
};
```
# src\views\desktop\auth\Login.jsx
```
// src/views/desktop/auth/Login.jsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../../contexts/AuthContext';
import { useEvent } from '../../../contexts/EventContext';

const DesktopLogin = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const { orgCode, eventCode, organization, event } = useEvent();

  const [formData, setFormData] = useState({
    phoneNumber: '',
    password: ''
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    if (error) setError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!formData.phoneNumber || !formData.password) {
      setError('è¯·å¡«å†™å®Œæ•´çš„æ‰‹æœºå·å’Œå¯†ç ');
      return;
    }

    if (!/^01\d{8,9}$/.test(formData.phoneNumber)) {
      setError('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥01å¼€å¤´çš„10-11ä½æ•°å­—');
      return;
    }

    if (formData.password.length < 8) {
      setError('å¯†ç è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦');
      return;
    }

    try {
      setLoading(true);
      setError('');

      await login(formData.phoneNumber, formData.password);

      // ç™»å½•æˆåŠŸï¼Œè·³è½¬åˆ°æ¡Œæœºç‰ˆé¦–é¡µ
      navigate(`/${orgCode}-${eventCode}/desktop`);
    } catch (err) {
      console.error('[DesktopLogin] Login failed:', err);
      setError(err.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={styles.container}>
      <div style={styles.leftPanel}>
        <div style={styles.brandSection}>
          <h1 style={styles.brandTitle}>
            {organization?.orgName?.['zh-CN'] || 'ä¹‰å–ä¼šç®¡ç†ç³»ç»Ÿ'}
          </h1>
          <p style={styles.brandSubtitle}>
            {event?.eventName?.['zh-CN'] || 'æ´»åŠ¨ç®¡ç†å¹³å°'}
          </p>
          <div style={styles.features}>
            <div style={styles.feature}>âœ“ å®‰å…¨å¯é </div>
            <div style={styles.feature}>âœ“ ç®€å•æ˜“ç”¨</div>
            <div style={styles.feature}>âœ“ å®æ—¶æ›´æ–°</div>
          </div>
        </div>
      </div>

      <div style={styles.rightPanel}>
        <div style={styles.loginCard}>
          <div style={styles.header}>
            <h2 style={styles.title}>æ¬¢è¿å›æ¥</h2>
            <p style={styles.subtitle}>è¯·ç™»å½•æ‚¨çš„è´¦å·</p>
          </div>

          <form onSubmit={handleSubmit} style={styles.form}>
            <div style={styles.formGroup}>
              <label style={styles.label}>æ‰‹æœºå·</label>
              <input
                type="tel"
                name="phoneNumber"
                value={formData.phoneNumber}
                onChange={handleChange}
                placeholder="01xxxxxxxx"
                style={styles.input}
                disabled={loading}
                inputMode="numeric"
                pattern="^01\d{8,9}$"
                maxLength="11"
              />
              <small style={styles.hint}>é©¬æ¥è¥¿äºšæ‰‹æœºå·ï¼Œ01å¼€å¤´</small>
            </div>

            <div style={styles.formGroup}>
              <label style={styles.label}>å¯†ç </label>
              <input
                type="password"
                name="password"
                value={formData.password}
                onChange={handleChange}
                placeholder="è‡³å°‘8ä½ï¼ŒåŒ…å«è‹±æ–‡å’Œæ•°å­—"
                style={styles.input}
                disabled={loading}
                minLength="8"
              />
            </div>

            {error && (
              <div style={styles.errorMessage}>
                âš ï¸ {error}
              </div>
            )}

            <button
              type="submit"
              style={{
                ...styles.submitButton,
                ...(loading ? styles.submitButtonDisabled : {})
              }}
              disabled={loading}
            >
              {loading ? 'ç™»å½•ä¸­...' : 'ç™»å½•'}
            </button>
          </form>

          <div style={styles.footer}>
            <p style={styles.footerText}>
              è¿˜æ²¡æœ‰è´¦å·ï¼Ÿè¯·è”ç³»ç®¡ç†å‘˜æ³¨å†Œ
            </p>
          </div>
        </div>
      </div>
    </div>
  );
};

const styles = {
  container: {
    display: 'flex',
    minHeight: '100vh'
  },
  leftPanel: {
    flex: 1,
    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: '3rem',
    color: 'white'
  },
  brandSection: {
    maxWidth: '500px'
  },
  brandTitle: {
    fontSize: '2.5rem',
    fontWeight: 'bold',
    marginBottom: '1rem',
    lineHeight: '1.2'
  },
  brandSubtitle: {
    fontSize: '1.25rem',
    opacity: 0.9,
    marginBottom: '3rem'
  },
  features: {
    display: 'flex',
    flexDirection: 'column',
    gap: '1rem'
  },
  feature: {
    fontSize: '1.125rem',
    opacity: 0.95
  },
  rightPanel: {
    flex: 1,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: '3rem',
    background: '#f9fafb'
  },
  loginCard: {
    background: 'white',
    borderRadius: '16px',
    padding: '3rem',
    width: '100%',
    maxWidth: '450px',
    boxShadow: '0 10px 40px rgba(0, 0, 0, 0.1)'
  },
  header: {
    marginBottom: '2rem'
  },
  title: {
    fontSize: '2rem',
    fontWeight: 'bold',
    color: '#1f2937',
    margin: '0 0 0.5rem 0'
  },
  subtitle: {
    fontSize: '1rem',
    color: '#6b7280',
    margin: 0
  },
  form: {
    display: 'flex',
    flexDirection: 'column',
    gap: '1.5rem'
  },
  formGroup: {
    display: 'flex',
    flexDirection: 'column',
    gap: '0.5rem'
  },
  label: {
    fontSize: '0.875rem',
    fontWeight: '600',
    color: '#374151'
  },
  input: {
    padding: '0.875rem',
    fontSize: '1rem',
    border: '1px solid #d1d5db',
    borderRadius: '8px',
    outline: 'none',
    transition: 'border-color 0.2s',
    width: '100%',
    boxSizing: 'border-box'
  },
  hint: {
    fontSize: '0.75rem',
    color: '#6b7280'
  },
  errorMessage: {
    padding: '0.875rem',
    background: '#fee2e2',
    color: '#991b1b',
    borderRadius: '8px',
    fontSize: '0.875rem',
    border: '1px solid #fecaca'
  },
  submitButton: {
    padding: '1rem',
    fontSize: '1rem',
    fontWeight: '600',
    color: 'white',
    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    border: 'none',
    borderRadius: '8px',
    cursor: 'pointer',
    transition: 'transform 0.2s, opacity 0.2s',
    marginTop: '0.5rem'
  },
  submitButtonDisabled: {
    opacity: 0.6,
    cursor: 'not-allowed'
  },
  footer: {
    marginTop: '2rem',
    paddingTop: '2rem',
    borderTop: '1px solid #e5e7eb',
    textAlign: 'center'
  },
  footerText: {
    fontSize: '0.875rem',
    color: '#6b7280',
    margin: 0
  }
};

export default DesktopLogin;
```

# src\contexts\EventContext.jsx
```
// src/contexts/EventContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import { db } from '../config/firebase';
import { collection, query, where, getDocs } from 'firebase/firestore';

const EventContext = createContext();

export const useEvent = () => {
  const context = useContext(EventContext);
  if (!context) {
    throw new Error('useEvent must be used within EventProvider');
  }
  return context;
};

export const EventProvider = ({ children }) => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [organizationId, setOrganizationId] = useState(null);
  const [eventId, setEventId] = useState(null);
  const [organization, setOrganization] = useState(null);
  const [event, setEvent] = useState(null);

  // å¾ URL è§£æçµ„ç¹”å’Œæ´»å‹•ä»£ç¢¼
  // URL æ ¼å¼: /fch-2025/phone æˆ– /fch-2025/desktop
  const urlPath = window.location.pathname;
  const match = urlPath.match(/\/([a-z]+)-(\d+)\/(phone|desktop)/);
  
  const orgCode = match ? match[1] : null;
  const eventCode = match ? match[2] : null;

  useEffect(() => {
    if (!orgCode || !eventCode) {
      setLoading(false);
      return;
    }

    loadEventData();
  }, [orgCode, eventCode]);

  const loadEventData = async () => {
    try {
      setLoading(true);
      setError(null);

      // 1. æ ¹æ“š orgCode æŸ¥æ‰¾çµ„ç¹”
      const orgsSnapshot = await getDocs(
        query(collection(db, 'organizations'), where('orgCode', '==', orgCode))
      );

      if (orgsSnapshot.empty) {
        throw new Error(`æ‰¾ä¸åˆ°çµ„ç¹”ä»£ç¢¼: ${orgCode}`);
      }

      const orgDoc = orgsSnapshot.docs[0];
      const orgId = orgDoc.id;
      const orgData = orgDoc.data();

      setOrganizationId(orgId);
      setOrganization({ id: orgId, ...orgData });

      // 2. æ ¹æ“š eventCode æŸ¥æ‰¾æ´»å‹•
      const eventsSnapshot = await getDocs(
        query(
          collection(db, 'organizations', orgId, 'events'),
          where('eventCode', '==', eventCode)
        )
      );

      if (eventsSnapshot.empty) {
        throw new Error(`æ‰¾ä¸åˆ°æ´»å‹•ä»£ç¢¼: ${eventCode}`);
      }

      const eventDoc = eventsSnapshot.docs[0];
      const evtId = eventDoc.id;
      const evtData = eventDoc.data();

      setEventId(evtId);
      setEvent({ id: evtId, ...evtData });

      console.log('[EventContext] Loaded:', {
        orgCode,
        eventCode,
        orgId,
        eventId: evtId
      });
    } catch (err) {
      console.error('[EventContext] Error:', err);
      setError(err.message);
    } finally {
      setLoading(false);
    }
  };

  // ç²å–é›†åˆè·¯å¾‘ï¼ˆè‡ªå‹•åŠ ä¸Š org å’Œ event å‰ç¶´ï¼‰
  const getCollectionPath = (collectionName) => {
    if (!organizationId || !eventId) {
      throw new Error('Organization or Event not loaded');
    }
    return `organizations/${organizationId}/events/${eventId}/${collectionName}`;
  };

  // ç²å– Firestore é›†åˆå¼•ç”¨
  const getCollection = (collectionName) => {
    return collection(db, getCollectionPath(collectionName));
  };

  const value = {
    loading,
    error,
    organizationId,
    eventId,
    organization,
    event,
    orgCode,
    eventCode,
    getCollectionPath,
    getCollection,
    reload: loadEventData
  };

  return (
    <EventContext.Provider value={value}>
      {children}
    </EventContext.Provider>
  );
};
```
