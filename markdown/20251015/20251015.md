# functions\index.js
```
const functions = require('firebase-functions');
const admin = require('firebase-admin');
const crypto = require('crypto');
const cors = require('cors'); // ğŸ”¥ æ·»åŠ è¿™ä¸€è¡Œï¼

// ç¡®ä¿åªåˆå§‹åŒ–ä¸€æ¬¡
if (!admin.apps.length) {
  admin.initializeApp();
}

const { checkAdminExists, createInitialAdmin, sendOtpToPhone, verifyOtpCode, setProjectInfo, getTotalCapital, getAssignedCapitalSum, createManager } = require('./admin');
exports.checkAdminExists = checkAdminExists;
exports.createInitialAdmin = createInitialAdmin;
exports.sendOtpToPhone = sendOtpToPhone;
exports.verifyOtpCode = verifyOtpCode;
exports.setProjectInfo = setProjectInfo;
exports.getTotalCapital = getTotalCapital;
exports.getAssignedCapitalSum = getAssignedCapitalSum;
exports.createManager = createManager;

// ğŸ”¥ CORS ä¸­é—´ä»¶é…ç½®
const corsHandler = cors({
  origin: [
    'http://localhost:5173',
    'http://localhost:3000',
    'https://mybazaar-c4881.web.app',
    'https://mybazaar-c4881.firebaseapp.com'
  ],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
});

// æ ‡å‡†åŒ–æ‰‹æœºå·ç æ ¼å¼
function normalizePhoneNumber(phoneNumber) {
  if (!phoneNumber) return null;
  
  let cleaned = phoneNumber.replace(/[\s\-\(\)]/g, '');
  
  if (cleaned.startsWith('+60')) {
    cleaned = cleaned.substring(3);
  } else if (cleaned.startsWith('60')) {
    cleaned = cleaned.substring(2);
  }
  
  if (cleaned.startsWith('0')) {
    cleaned = cleaned.substring(1);
  }
  
  return cleaned;
}

// è·å–é‡å®šå‘ URL
function getRedirectUrl(roles) {
  console.log(`[getRedirectUrl] Checking roles:`, JSON.stringify(roles));
  if (!roles || !Array.isArray(roles)) return "../home/index.html";
  
  if (roles.includes("super_admin") || roles.includes("super admin")) 
    return "../admin/admin-dashboard.html";
  if (roles.includes("manager")) 
    return "../manager/admin-manage-users.html";
  if (roles.includes("merchant")) 
    return "../merchant/merchant-dashboard.html";
  if (roles.includes("seller")) 
    return "../seller/seller-dashboard.html";
  if (roles.includes("customer")) 
    return "../customer/consume.html";
  
  console.log(`[getRedirectUrl] No role matched, returning default`);
  return "../home/index.html";
}

// ğŸ”¥ ç™»å½•å‡½æ•° - ä½¿ç”¨ corsHandler
exports.loginWithPin = functions.https.onRequest((req, res) => {
  corsHandler(req, res, async () => { // ğŸ”¥ ä½¿ç”¨ corsHandler è€Œä¸æ˜¯ cors
    const startTime = Date.now();
    const requestId = Math.random().toString(36).substring(7);
    
    console.log(`[${requestId}] ===== LOGIN REQUEST START =====`);
    console.log(`[${requestId}] Method: ${req.method}`);
    
    try {
      if (req.method !== 'POST') {
        console.log(`[${requestId}] âŒ Invalid method: ${req.method}`);
        return res.status(405).json({ 
          error: { code: 'method-not-allowed', message: 'åªæ”¯æŒ POST è¯·æ±‚' }
        });
      }

      const { phoneNumber, pin, organizationId, eventId } = req.body;
    
      console.log(`[${requestId}] ğŸ“¥ Received data:`, { 
        phoneNumber: phoneNumber ? `${phoneNumber.substring(0, 3)}***` : 'missing',
        hasPin: !!pin,
        pinLength: pin ? pin.length : 0,
        organizationId,
        eventId
      });
    
      if (!phoneNumber || !pin) {
        console.log(`[${requestId}] âŒ Missing phone or pin`);
        return res.status(400).json({ 
          error: { code: 'invalid-argument', message: 'è¯·æä¾›æ‰‹æœºå·ç ä¸å¯†ç ' }
        });
      }
      
      if (!organizationId || !eventId) {
        console.log(`[${requestId}] âŒ Missing organizationId or eventId`);
        return res.status(400).json({ 
          error: { code: 'invalid-argument', message: 'è¯·æä¾›ç»„ç»‡ä¸æ´»åŠ¨ä¿¡æ¯' }
        });
      }
    
      const normalizedPhone = normalizePhoneNumber(phoneNumber);
      console.log(`[${requestId}] ğŸ“± Normalized phone: ${normalizedPhone}`);
    
      const collectionPath = `organizations/${organizationId}/events/${eventId}/users`;
      console.log(`[${requestId}] ğŸ“‚ Collection path: ${collectionPath}`);
    
      const phoneVariants = [
        normalizedPhone,
        `0${normalizedPhone}`,
        `60${normalizedPhone}`,
        `+60${normalizedPhone}`,
        phoneNumber
      ];
    
      console.log(`[${requestId}] ğŸ” Trying phone variants:`, phoneVariants);
    
      let userDoc = null;
      let usedVariant = null;
      
      for (const variant of phoneVariants) {
        console.log(`[${requestId}] ğŸ” Querying with variant: ${variant}`);
        
        try {
          const usersSnap = await admin.firestore()
            .collection(collectionPath)
            .where("basicInfo.phoneNumber", "==", variant)
            .limit(1)
            .get();
          
          console.log(`[${requestId}] Query result for ${variant}: ${usersSnap.size} documents`);
          
          if (!usersSnap.empty) {
            userDoc = usersSnap.docs[0];
            usedVariant = variant;
            console.log(`[${requestId}] âœ… Found user with variant: ${variant}, Doc ID: ${userDoc.id}`);
            break;
          }
        } catch (queryError) {
          console.error(`[${requestId}] âŒ Query error for ${variant}:`, queryError);
        }
      }
    
      if (!userDoc) {
        console.log(`[${requestId}] âŒ User not found for any phone variant`);
        return res.status(404).json({ 
          error: { code: 'not-found', message: 'æŸ¥æ— æ­¤æ‰‹æœºå·ç ' }
        });
      }
    
      const userData = userDoc.data();
      console.log(`[${requestId}] ğŸ“„ User data structure:`, {
        id: userDoc.id,
        hasBasicInfo: !!userData.basicInfo,
        phoneNumber: userData.basicInfo?.phoneNumber,
        hasPasswordHash: !!userData.basicInfo?.passwordHash,
        hasPinHash: !!userData.basicInfo?.pinHash,
        hasPasswordSalt: !!userData.basicInfo?.passwordSalt,
        hasPinSalt: !!userData.basicInfo?.pinSalt,
        roles: userData.roles,
        topLevelKeys: Object.keys(userData)
      });
    
      const passwordSalt = userData.basicInfo?.passwordSalt || userData.basicInfo?.pinSalt;
      const storedHash = userData.basicInfo?.passwordHash || userData.basicInfo?.pinHash;
    
      if (!passwordSalt || !storedHash) {
        console.error(`[${requestId}] âŒ Missing password data`);
        return res.status(412).json({ 
          error: { code: 'failed-precondition', message: 'ç”¨æˆ·å¯†ç èµ„æ–™ä¸å®Œæ•´ï¼Œè¯·è”ç³»ç®¡ç†å‘˜' }
        });
      }
      
      console.log(`[${requestId}] ğŸ”’ Computing password hash...`);
      const passwordHash = crypto.createHash("sha256")
        .update(pin + passwordSalt)
        .digest("hex");
    
      if (passwordHash !== storedHash) {
        console.log(`[${requestId}] âŒ Password mismatch`);
        return res.status(403).json({ 
          error: { code: 'permission-denied', message: 'å¯†ç é”™è¯¯' }
        });
      }
      
      console.log(`[${requestId}] âœ… Password verified`);
    
      const authUid = `phone_60${normalizedPhone}`;
      console.log(`[${requestId}] ğŸ”‘ AuthUid: ${authUid}`);
    
      let userRecord;
      let skipAuthUserOps = false; // å½“ Auth é…ç½®ç¼ºå¤±æ—¶ï¼Œè·³è¿‡ getUser/createUserï¼Œç›´æ¥ç­¾å‘è‡ªå®šä¹‰ Token
      try {
        console.log(`[${requestId}] ğŸ” Checking if auth user exists...`);
        userRecord = await admin.auth().getUser(authUid);
        console.log(`[${requestId}] âœ… Existing auth user found`);
      } catch (error) {
        if (error.code === 'auth/user-not-found') {
          console.log(`[${requestId}] ğŸ“ Creating new auth user...`);
          try {
            userRecord = await admin.auth().createUser({
              uid: authUid,
              displayName: userData.basicInfo?.englishName || 
                          userData.basicInfo?.chineseName || 
                          phoneNumber
            });
            console.log(`[${requestId}] âœ… Auth user created`);
          } catch (createError) {
            console.error(`[${requestId}] âŒ Failed to create auth user:`, createError);
            throw createError;
          }
        } else if (error.code === 'auth/configuration-not-found' || (typeof error.message === 'string' && error.message.toLowerCase().includes('configuration'))) {
          // åœ¨æœªå¯ç”¨ Firebase Authenticationï¼ˆæˆ–é…ç½®ä¸å®Œæ•´ï¼‰æ—¶ï¼ŒAdmin SDK çš„éƒ¨åˆ†æ“ä½œä¼šæŠ¥é”™
          // ä¸ºäº†ä¸ä¸­æ–­ç™»å½•æµç¨‹ï¼Œè¿™é‡Œè·³è¿‡ç”¨æˆ·æŸ¥è¯¢/åˆ›å»ºï¼Œç›´æ¥èµ°è‡ªå®šä¹‰ Token æµç¨‹
          skipAuthUserOps = true;
          console.warn(`[${requestId}] âš ï¸ Auth configuration not found. Skipping getUser/createUser and proceeding to custom token only.`);
        } else {
          console.error(`[${requestId}] âŒ Error checking auth user:`, error);
          throw error;
        }
      }
    
      console.log(`[${requestId}] ğŸ« Creating custom token...`);
      const customToken = await admin.auth().createCustomToken(authUid, {
        orgId: organizationId,
        eventId: eventId,
        userId: userDoc.id
      });
      console.log(`[${requestId}] âœ… Custom token created (length: ${customToken.length})`);
    
      const currentAuthUid = userData.authUid || 
                            userData.authId || 
                            userData.accountStatus?.authUid;
                            
      if (currentAuthUid !== authUid) {
        console.log(`[${requestId}] ğŸ“ Updating authUid in Firestore`);
        await userDoc.ref.update({ 
          authUid: authUid,
          'accountStatus.authUid': authUid,
          'accountStatus.lastLoginAt': admin.firestore.FieldValue.serverTimestamp(),
          'accountStatus.updatedAt': admin.firestore.FieldValue.serverTimestamp()
        });
        console.log(`[${requestId}] âœ… AuthUid updated in Firestore`);
      }
    
      const userProfile = {
        id: userDoc.id,
        orgId: organizationId,
        eventId: eventId,
        authUid: authUid,
        basicInfo: userData.basicInfo,
        roles: userData.roles || [],
        identityTag: userData.basicInfo?.identityTag || "",
        roleSpecificData: userData.roleSpecificData || {}
      };
    
      const duration = Date.now() - startTime;
      console.log(`[${requestId}] âœ… Login successful in ${duration}ms`);
      console.log(`[${requestId}] ===== LOGIN REQUEST END =====`);
    
      return res.status(200).json({
        success: true,
        customToken,
        userProfile,
        chineseName: userData.basicInfo?.chineseName || "",
        roles: userData.roles || [],
        redirectUrl: getRedirectUrl(userData.roles || [])
      });
    
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`[${requestId}] âŒ ERROR after ${duration}ms:`, {
        name: error.name,
        message: error.message,
        code: error.code,
        stack: error.stack
      });
    
      return res.status(500).json({ 
        error: { 
          code: error.code || 'internal',
          message: error.message || 'ç™»å…¥å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•',
          requestId: requestId
        }
      });
    }
  });
});

// changePassword å‡½æ•°
exports.changePassword = functions.https.onCall(async (data, context) => {
  const { phoneNumber, currentPassword, newPassword } = data;
  
  if (!phoneNumber || !currentPassword || !newPassword) {
    throw new functions.https.HttpsError("invalid-argument", "è¯·æä¾›æ‰‹æœºå·ç ã€å½“å‰å¯†ç å’Œæ–°å¯†ç ");
  }
  
  if (newPassword.length < 8) {
    throw new functions.https.HttpsError("invalid-argument", "æ–°å¯†ç é•¿åº¦è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦");
  }
  
  const hasLetter = /[a-zA-Z]/.test(newPassword);
  const hasNumber = /[0-9]/.test(newPassword);
  
  if (!hasLetter || !hasNumber) {
    throw new functions.https.HttpsError("invalid-argument", "æ–°å¯†ç å¿…é¡»åŒ…å«è‹±æ–‡å­—æ¯å’Œæ•°å­—");
  }
  
  try {
    const normalizedPhone = normalizePhoneNumber(phoneNumber);
    const phoneVariants = [
      normalizedPhone,
      `0${normalizedPhone}`,
      `60${normalizedPhone}`,
      phoneNumber
    ];
    
    let userDoc = null;
    
    for (const variant of phoneVariants) {
      const usersSnap = await admin.firestore().collection("users")
        .where("basicInfo.phoneNumber", "==", variant)
        .limit(1)
        .get();
      
      if (!usersSnap.empty) {
        userDoc = usersSnap.docs[0];
        break;
      }
    }
    
    if (!userDoc) {
      throw new functions.https.HttpsError("not-found", "æŸ¥æ— æ­¤æ‰‹æœºå·ç ");
    }
    
    const userData = userDoc.data();
    
    const passwordSalt = userData.basicInfo.passwordSalt || userData.basicInfo.pinSalt;
    const currentPasswordHash = crypto.createHash("sha256")
      .update(currentPassword + passwordSalt)
      .digest("hex");
    
    const storedHash = userData.basicInfo.passwordHash || userData.basicInfo.pinHash;
    if (currentPasswordHash !== storedHash) {
      throw new functions.https.HttpsError("permission-denied", "å½“å‰å¯†ç é”™è¯¯");
    }
    
    const newPasswordHash = crypto.createHash("sha256")
      .update(newPassword + passwordSalt)
      .digest("hex");
    
    await userDoc.ref.update({
      "basicInfo.passwordHash": newPasswordHash,
      "basicInfo.pinHash": newPasswordHash,
      "basicInfo.passwordSalt": passwordSalt,
      "basicInfo.pinSalt": passwordSalt
    });
    
    console.log(`[changePassword] Password changed for ${phoneNumber}`);
    return { success: true, message: "å¯†ç ä¿®æ”¹æˆåŠŸ" };
    
  } catch (error) {
    console.error("[changePassword] Error:", error);
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError("internal", `ä¿®æ”¹å¯†ç å¤±è´¥ï¼š${error.message}`);
  }
});

exports.loginAndRedirect = functions.https.onCall(async (data, context) => {
  const userUid = context.auth ? context.auth.uid : null;
  console.log(`[loginAndRedirect] User UID from context: ${userUid}`);
  
  const { phoneNumber } = data;
  
  let userSnap;
  if (userUid) {
    userSnap = await admin.firestore().collection("users")
      .where("authUid", "==", userUid)
      .limit(1)
      .get();
  }
  
  if ((!userSnap || userSnap.empty) && phoneNumber) {
    console.log(`[loginAndRedirect] Fallback to phoneNumber query: ${phoneNumber}`);
    userSnap = await admin.firestore().collection("users")
      .where("basicInfo.phoneNumber", "==", phoneNumber)
      .limit(1)
      .get();
  }
  
  console.log(`[loginAndRedirect] Query result: ${userSnap && !userSnap.empty ? 'found' : 'empty'}`);
  if (!userSnap || userSnap.empty) {
    throw new functions.https.HttpsError("not-found", "æ‰¾ä¸åˆ°ä½¿ç”¨è€…èµ„æ–™ã€‚");
  }
  
  const userData = userSnap.docs[0].data();
  return {
    redirectUrl: getRedirectUrl(userData.roles),
    chineseName: userData.basicInfo?.chineseName || "",
    roles: userData.roles,
    identityTag: userData.identityTag || "",
  };
});

exports.getManagers = functions.https.onCall(async (data, context) => {
  try {
    const managersSnap = await admin.firestore().collection("managers").get();
    const managers = [];

    managersSnap.forEach(doc => {
      managers.push({
        id: doc.id,
        ...doc.data()
      });
    });

    return { managers };
  } catch (error) {
    console.error("Error fetching managers:", error);
    throw new functions.https.HttpsError("internal", "Unable to fetch managers.");
  }
});

// ğŸ”¥ æµ‹è¯•å‡½æ•°
exports.testFirestoreAccess = functions.https.onRequest(async (req, res) => {
  res.set('Access-Control-Allow-Origin', '*');

  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  try {
    console.log('=== TEST START ===');

    const { orgId, eventId, phoneNumber } = req.query;

    if (!orgId || !eventId || !phoneNumber) {
      return res.status(400).json({
        error: 'Missing parameters',
        usage: '?orgId=xxx&eventId=xxx&phoneNumber=xxx'
      });
    }

    const collectionPath = `organizations/${orgId}/events/${eventId}/users`;
    console.log('Collection path:', collectionPath);

    const allUsers = await admin.firestore()
      .collection(collectionPath)
      .limit(5)
      .get();

    console.log(`Found ${allUsers.size} users`);

    const usersList = allUsers.docs.map(doc => {
      const data = doc.data();
      return {
        id: doc.id,
        phoneNumber: data.basicInfo?.phoneNumber,
        hasPasswordHash: !!data.basicInfo?.passwordHash,
        hasPinHash: !!data.basicInfo?.pinHash,
        roles: data.roles
      };
    });

    const userQuery = await admin.firestore()
      .collection(collectionPath)
      .where('basicInfo.phoneNumber', '==', phoneNumber)
      .limit(1)
      .get();

    let foundUser = null;
    if (!userQuery.empty) {
      const doc = userQuery.docs[0];
      const data = doc.data();
      foundUser = {
        id: doc.id,
        phoneNumber: data.basicInfo?.phoneNumber,
        hasPasswordHash: !!data.basicInfo?.passwordHash,
        hasPinHash: !!data.basicInfo?.pinHash,
        basicInfoKeys: data.basicInfo ? Object.keys(data.basicInfo) : []
      };
    }

    console.log('=== TEST END ===');

    return res.status(200).json({
      success: true,
      collectionPath,
      totalUsers: allUsers.size,
      usersList,
      queriedPhone: phoneNumber,
      foundUser
    });

  } catch (error) {
    console.error('TEST ERROR:', error);
    return res.status(500).json({
      error: error.message,
      code: error.code
    });
  }
});
```

# functions\admin.js
```
const admin = require('firebase-admin');
const functions = require('firebase-functions');
const crypto = require('crypto');

function getDb() {
  return admin.firestore();
}

function sha256(str) {
  return crypto.createHash("sha256").update(str).digest("hex");
}

// ========== OTP ç›¸å…³å‡½æ•° ==========

exports.sendOtpToPhone = functions.https.onCall(async (data, context) => {
  const { phoneNumber, pinCode } = data;
  if (!phoneNumber || !pinCode) throw new functions.https.HttpsError("invalid-argument", "ç¼ºå°‘å‚æ•°");

  const usersSnap = await getDb().collection("users").where("basicInfo.phoneNumber", "==", phoneNumber).get();
  if (usersSnap.empty) throw new functions.https.HttpsError("not-found", "ç”¨æˆ·ä¸å­˜åœ¨");
  const userDoc = usersSnap.docs[0];
  const user = userDoc.data();

  const pinSalt = user.basicInfo && user.basicInfo.pinSalt ? user.basicInfo.pinSalt : undefined;
  const pinHash = user.basicInfo && user.basicInfo.pinHash ? user.basicInfo.pinHash : undefined;
  if (!pinSalt || !pinHash) throw new functions.https.HttpsError("failed-precondition", "PIN èµ„æ–™ç¼ºå¤±");
  if (sha256(pinCode + pinSalt) !== pinHash) throw new functions.https.HttpsError("permission-denied", "PIN éªŒè¯å¤±è´¥");

  const otpCode = Math.floor(100000 + Math.random() * 900000).toString();
  const otpCodeHash = sha256(otpCode);
  const sessionId = crypto.randomUUID();
  const expiresAt = Date.now() + 5 * 60 * 1000;

  await getDb().collection("otp_collection").doc(sessionId).set({
    sessionId,
    phoneNumber,
    otpCodeHash,
    expiresAt,
    attempts: 0,
    authUid: user.authUid
  });

  console.log(`[OTP] Send to ${phoneNumber}: ${otpCode}`);
  return { sessionId };
});

exports.verifyOtpCode = functions.https.onCall(async (data, context) => {
  const { sessionId, otpCode } = data;
  if (!sessionId || !otpCode) throw new functions.https.HttpsError("invalid-argument", "ç¼ºå°‘å‚æ•°");

  const otpDocRef = getDb().collection("otp_collection").doc(sessionId);
  const otpDocSnap = await otpDocRef.get();
  if (!otpDocSnap.exists) throw new functions.https.HttpsError("not-found", "OTP session ä¸å­˜åœ¨");
  const otpData = otpDocSnap.data();
  if (!otpData) throw new functions.https.HttpsError("not-found", "OTP èµ„æ–™ä¸å­˜åœ¨");
  if (Date.now() > otpData.expiresAt) throw new functions.https.HttpsError("deadline-exceeded", "OTP å·²è¿‡æœŸ");
  if (sha256(otpCode) !== otpData.otpCodeHash) {
    await otpDocRef.update({ attempts: (otpData.attempts || 0) + 1 });
    throw new functions.https.HttpsError("permission-denied", "OTP éªŒè¯å¤±è´¥");
  }
  const customToken = await admin.auth().createCustomToken(otpData.authUid);
  await otpDocRef.delete();
  return { customToken };
});

// ========== ç®¡ç†å‘˜æ£€æŸ¥ä¸åˆå§‹åŒ– ==========

exports.checkAdminExists = functions.https.onCall(async (data, context) => {
  try {
    const snapshot = await getDb().collection('users')
      .where('roles', 'array-contains', 'super_admin')
      .limit(1)
      .get();
    const exists = !snapshot.empty;
    return { exists };
  } catch (error) {
    throw new functions.https.HttpsError("internal", "æ£€æŸ¥ç®¡ç†å‘˜å¤±è´¥");
  }
});

exports.createInitialAdmin = functions.https.onCall(async (data, context) => {
  const actualData = data.data || data;
  const { 
    phoneNumber, 
    englishName, 
    chineseName, 
    email,
    identityTag,
    department,
    password,
    includeMerchant,
    projectInfo 
  } = actualData;

  console.log('[createInitialAdmin] Received data:', { 
    phoneNumber, 
    englishName, 
    chineseName, 
    email,
    identityTag,
    department,
    hasPassword: !!password,
    includeMerchant,
    hasProjectInfo: !!projectInfo 
  });

  // éªŒè¯å¿…å¡«å­—æ®µ
  if (!phoneNumber || !englishName || !email || !password || typeof phoneNumber !== 'string') {
    throw new functions.https.HttpsError('invalid-argument', 'ç¼ºå°‘æ‰‹æœºå·ç ã€è‹±æ–‡å§“åã€é‚®ç®±æˆ–å¯†ç ');
  }

  // éªŒè¯èº«ä»½æ ‡ç­¾ - åªå…è®¸ staff å’Œ teacher
  const validIdentityTags = ['staff', 'teacher'];
  if (!identityTag || !validIdentityTags.includes(identityTag)) {
    throw new functions.https.HttpsError('invalid-argument', 'è¯·é€‰æ‹©æœ‰æ•ˆçš„èº«ä»½æ ‡ç­¾ (staff æˆ– teacher)');
  }

  // æ£€æŸ¥æ˜¯å¦å·²æœ‰è¶…çº§ç®¡ç†å‘˜
  const check = await getDb().collection('users')
    .where('roles', 'array-contains', 'super_admin')
    .limit(1)
    .get();
  
  if (!check.empty) {
    throw new functions.https.HttpsError('already-exists', 'å·²æœ‰ç®¡ç†å‘˜,æ— æ³•é‡å¤åˆå§‹åŒ–');
  }

  // å¤„ç†å›½é™…ç”µè¯å·ç æ ¼å¼
  const internationalPhone = phoneNumber.startsWith('+')
    ? phoneNumber
    : `+${phoneNumber.replace(/^0/, '60')}`;

  let userRecord;
  try {
    userRecord = await admin.auth().getUserByPhoneNumber(internationalPhone);
    userRecord = await admin.auth().updateUser(userRecord.uid, {
      displayName: englishName,
      email: email
    });
  } catch (error) {
    if (error.code === 'auth/user-not-found') {
      userRecord = await admin.auth().createUser({
        phoneNumber: internationalPhone,
        displayName: englishName,
        email: email
      });
    } else {
      throw error;
    }
  }

  // ç”Ÿæˆæ–‡æ¡£ID
  const docId = `usr_${crypto.randomUUID()}`;
  
  // ç”Ÿæˆå¯†ç  hash å’Œ salt
  const passwordSalt = crypto.randomBytes(16).toString('hex');
  const passwordHash = sha256(password + passwordSalt);

  // æ£€æŸ¥æ–‡æ¡£æ˜¯å¦å·²å­˜åœ¨
  const existingUserDoc = await getDb().collection('users').doc(docId).get();
  if (existingUserDoc.exists) {
    throw new functions.https.HttpsError('already-exists', 'ç”¨æˆ·æ–‡ä»¶å·²å­˜åœ¨');
  }

  // æ„å»ºè§’è‰²æ•°ç»„ï¼šsuper_admin + seller + customer + (å¯é€‰)merchant
  const roles = ['super_admin', 'seller', 'customer'];
  if (includeMerchant) {
    roles.push('merchant');
  }

  console.log('[createInitialAdmin] Roles assigned:', roles);

  // æ„å»º identityInfo åŸºäº identityTag
  let identityInfo = {};
  let superAdminId = 'SA001';
  
  switch (identityTag) {
    case 'staff':
      identityInfo = {
        staffId: superAdminId,
        position: 'super_admin',
        department: department || 'ç³»ç»Ÿç®¡ç†éƒ¨'
      };
      break;
    case 'teacher':
      identityInfo = {
        teacherId: superAdminId,
        department: department || 'ç³»ç»Ÿç®¡ç†éƒ¨'
      };
      break;
  }

  // è·å–æ€»èµ„æœ¬
  const totalCapital = projectInfo?.settings?.totalCapital || 2000000;

  // æ„å»º roleSpecificData - åŒ…å«æ‰€æœ‰è§’è‰²çš„æ•°æ®
  const roleSpecificData = {
    super_admin: {
      superAdminId: superAdminId,
      totalCapitalManaged: totalCapital,
      allocatedCapital: 0,
      availableCapital: totalCapital,
      totalManagersAssigned: 0,
      allocationHistory: {
        totalAllocations: 0,
        lastAllocationAt: null,
        totalReclaimed: 0
      }
    },
    seller: {
      availablePoints: 0,
      currentSalesAmount: 0,
      totalPointsSold: 0,
      capitalSource: {
        assignedBy: 'self',
        assignedAt: new Date(),
        allocationId: null
      }
    },
    customer: {
      currentBalance: 0,
      totalPointsPurchased: 0,
      totalPointsConsumed: 0
    }
  };

  // å¦‚æœåŒ…å« merchant è§’è‰²ï¼Œæ·»åŠ  merchant æ•°æ®
  if (includeMerchant) {
    roleSpecificData.merchant = {
      totalReceivedPoints: 0,
      monthlyReceivedPoints: 0
    };
  }

  // åˆ›å»ºç”¨æˆ·æ–‡æ¡£ - å®Œå…¨ç¬¦åˆæ–°æ¶æ„
  const userDoc = {
    userId: docId,
    authUid: userRecord.uid,
    roles: roles,
    identityTag: identityTag,
    basicInfo: {
      phoneNumber: phoneNumber,
      englishName: englishName,
      chineseName: chineseName || '',
      email: email,
      pinHash: passwordHash,
      pinSalt: passwordSalt,
      passwordHash: passwordHash,
      passwordSalt: passwordSalt,
      isPhoneVerified: true
    },
    identityInfo: identityInfo,
    roleSpecificData: roleSpecificData,
    activityData: {
      joinedAt: new Date(),
      lastActiveAt: new Date(),
      participationStatus: 'active'
    },
    accountStatus: {
      status: 'active',
      mustChangePassword: false,
      createdAt: new Date(),
      updatedAt: new Date()
    },
    metadata: {
      registrationSource: 'initial_admin',
      operatorUid: context && context.auth && context.auth.uid ? context.auth.uid : 'system',
      notes: `ç³»ç»Ÿåˆå§‹åŒ–è¶…çº§ç®¡ç†å‘˜ - è§’è‰²: ${roles.join(', ')}${department ? ' - éƒ¨é—¨: ' + department : ''}`
    }
  };

  // å¦‚æœåŒ…å« merchantï¼Œæ·»åŠ  businessInfo
  if (includeMerchant) {
    userDoc.businessInfo = {
      businessType: 'general',
      operatingHours: {
        'zh-CN': 'ä¹‰å–ä¼šæœŸé—´è¥ä¸š',
        'en': 'Open during charity fair'
      },
      description: {
        'zh-CN': `${department || 'ç®¡ç†å‘˜'}æ¡£å£`,
        'en': `${department || 'Administrator'} stall`
      }
    };
  }

  // ä¿å­˜ç”¨æˆ·æ–‡æ¡£
  await getDb().collection('users').doc(docId).set(userDoc);

  // ä¿å­˜åˆ° admin_uids é›†åˆ
  await getDb().collection('admin_uids').doc(userRecord.uid).set({
    uid: userRecord.uid,
    englishName: englishName,
    chineseName: chineseName || '',
    email: email,
    department: department || '',
    permissions: ['all'],
    createdAt: new Date()
  });

  // ä¿å­˜é¡¹ç›®é…ç½®
  if (projectInfo) {
    try {
      console.log('[createInitialAdmin] Saving project info:', projectInfo);
      await getDb().collection('system_config').doc('project_info').set(projectInfo);
      console.log('[createInitialAdmin] Project info saved successfully');
    } catch (error) {
      console.error('[createInitialAdmin] Error saving project info:', error);
    }
  }

  // åˆå§‹åŒ–å…¨å±€è®¾ç½®
  await getDb().collection('system_config').doc('global_settings').set({
    defaultLanguage: 'zh-CN',
    supportedLanguages: ['zh-CN', 'en'],
    timezone: 'Asia/Kuala_Lumpur',
    currency: 'MYR',
    version: '4.2.0',
    features: {
      multiLanguage: true,
      otpVerification: true,
      transactionLogging: true,
      roleBasedPermissions: true,
      multiRoleSupport: true,
      capitalAllocationTracking: true
    },
    otp: {
      enabled: true,
      expirySeconds: 300,
      maxAttempts: 5,
      provider: 'twilio'
    },
    pin: {
      minLength: 6,
      maxLength: 6,
      hashAlgorithm: 'SHA-256',
      requireOtpVerification: true
    },
    nameFields: {
      englishName: {
        required: true,
        description: {
          'zh-CN': 'è‹±æ–‡åå­—æˆ–æ‹¼éŸ³åå­—(å¿…å¡«)',
          'en': 'English name or romanized name (required)'
        }
      },
      chineseName: {
        required: false,
        description: {
          'zh-CN': 'ä¸­æ–‡åå­—(é€‰å¡«)',
          'en': 'Chinese name (optional)'
        }
      }
    }
  });

  console.log('[createInitialAdmin] Super admin created successfully:', {
    userId: docId,
    authUid: userRecord.uid,
    englishName: englishName,
    identityTag: identityTag,
    department: department,
    roles: roles
  });

  return {
    success: true,
    userId: docId,
    authUid: userRecord.uid,
    roles: roles,
    department: department || '',
    message: 'ç®¡ç†å‘˜åˆ›å»ºæˆåŠŸ,è¯·ä½¿ç”¨æ‰‹æœºå· + å¯†ç ç™»å½•'
  };
});

// ========== é¡¹ç›®é…ç½®ç®¡ç† ==========

exports.setProjectInfo = functions.https.onCall(async (data, context) => {
  const { projectInfo } = data;
  if (!projectInfo) {
    throw new functions.https.HttpsError("invalid-argument", "ç¼ºå°‘ projectInfo èµ„æ–™");
  }

  try {
    await getDb().collection("system_config").doc("project_info").set(projectInfo);
    return { success: true, message: "é¡¹ç›®é…ç½®å·²æˆåŠŸä¿å­˜" };
  } catch (error) {
    console.error("ä¿å­˜é¡¹ç›®é…ç½®å¤±è´¥:", error);
    throw new functions.https.HttpsError("internal", "ä¿å­˜é¡¹ç›®é…ç½®å¤±è´¥", error.message);
  }
});

exports.getTotalCapital = functions.https.onCall(async (data, context) => {
  try {
    const projectInfoDoc = await getDb().collection('system_config').doc('project_info').get();
    
    if (!projectInfoDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'æ‰¾ä¸åˆ°ä¸“æ¡ˆé…ç½®');
    }
    
    const projectInfo = projectInfoDoc.data();
    const totalCapital = projectInfo.settings?.totalCapital || 0;
    const statistics = projectInfo.statistics || {};
    const assignedCapital = statistics.assignedCapital || 0;
    const availableCapital = statistics.availableCapital || totalCapital;
    
    console.log('[getTotalCapital] Capital info:', { totalCapital, assignedCapital, availableCapital });
    
    return { 
      totalCapital,
      assignedCapital,
      availableCapital
    };
  } catch (error) {
    console.error('[getTotalCapital] Error:', error);
    throw new functions.https.HttpsError('internal', 'å–å¾—æ€»èµ„æœ¬å¤±è´¥', error.message);
  }
});

exports.getAssignedCapitalSum = functions.https.onCall(async (data, context) => {
  try {
    const managersSnap = await getDb().collection('users')
      .where('roles', 'array-contains', 'manager')
      .get();
    
    let assignedSum = 0;
    managersSnap.forEach(doc => {
      const managerData = doc.data();
      assignedSum += managerData.roleSpecificData?.manager?.assignedCapital || 0;
    });
    
    console.log('[getAssignedCapitalSum] Assigned sum:', assignedSum);
    return { assignedSum };
  } catch (error) {
    console.error('[getAssignedCapitalSum] Error:', error);
    throw new functions.https.HttpsError('internal', 'å–å¾—åˆ†é…æ€»å’Œå¤±è´¥', error.message);
  }
});

// ========== Manager ç®¡ç† ==========

exports.createManager = functions.https.onCall(async (data, context) => {
  console.log('[createManager] Received request, context.auth:', context.auth ? context.auth.uid : 'null');
  
  const actualData = data.data || data;
  const callerUid = context.auth ? context.auth.uid : actualData.callerUid;
  
  console.log('[createManager] Caller UID:', callerUid);
  
  if (!callerUid) {
    throw new functions.https.HttpsError('unauthenticated', 'å¿…é¡»ç™»å…¥æ‰èƒ½æ‰§è¡Œæ­¤æ“ä½œ');
  }
  
  // éªŒè¯æƒé™
  try {
    const userQuery = await getDb().collection('users')
      .where('authUid', '==', callerUid)
      .limit(1)
      .get();
    
    let hasPermission = false;
    
    if (!userQuery.empty) {
      const userData = userQuery.docs[0].data();
      console.log('[createManager] Found user by authUid:', { 
        docId: userQuery.docs[0].id, 
        roles: userData.roles 
      });
      hasPermission = userData.roles && userData.roles.includes('super_admin');
    } else {
      const directDoc = await getDb().collection('users').doc(callerUid).get();
      if (directDoc.exists) {
        const userData = directDoc.data();
        console.log('[createManager] Found user by docId:', { 
          docId: directDoc.id, 
          roles: userData.roles 
        });
        hasPermission = userData.roles && userData.roles.includes('super_admin');
      }
    }
    
    if (!hasPermission) {
      console.log('[createManager] Permission denied: User is not super_admin');
      throw new functions.https.HttpsError('permission-denied', 'åªæœ‰è¶…çº§ç®¡ç†å‘˜å¯ä»¥å»ºç«‹ Manager');
    }
    
    console.log('[createManager] Permission check passed');
  } catch (error) {
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    console.error('[createManager] Permission check error:', error);
    throw new functions.https.HttpsError('internal', 'æƒé™éªŒè¯å¤±è´¥: ' + error.message);
  }
  
  const { phoneNumber, password, englishName, chineseName, identityTag, assignedCapital } = actualData;
  
  console.log('[createManager] Creating manager:', { 
    phoneNumber, 
    englishName, 
    chineseName, 
    identityTag,
    assignedCapital 
  });
  
  // éªŒè¯å¿…è¦æ ä½
  if (!phoneNumber || !password || !englishName || assignedCapital === undefined) {
    throw new functions.https.HttpsError('invalid-argument', 'ç¼ºå°‘å¿…è¦æ ä½');
  }
  
  // éªŒè¯å¯†ç å¼ºåº¦
  if (password.length < 8) {
    throw new functions.https.HttpsError('invalid-argument', 'å¯†ç è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦');
  }
  
  if (!/[a-zA-Z]/.test(password) || !/\d/.test(password)) {
    throw new functions.https.HttpsError('invalid-argument', 'å¯†ç å¿…é¡»åŒ…å«è‹±æ–‡å­—æ¯å’Œæ•°å­—');
  }
  
  // éªŒè¯èº«ä»½æ ‡ç­¾ (manager å¿…é¡»æœ‰èº«ä»½æ ‡ç­¾)
  const validIdentityTags = ['staff', 'teacher'];
  if (!identityTag || !validIdentityTags.includes(identityTag)) {
    throw new functions.https.HttpsError('invalid-argument', 'Manager å¿…é¡»é€‰æ‹©æœ‰æ•ˆçš„èº«ä»½æ ‡ç­¾ (staff æˆ– teacher)');
  }
  
  try {
    // æ£€æŸ¥æ‰‹æœºå·ç æ˜¯å¦å·²å­˜åœ¨
    const existingUserSnap = await getDb().collection('users')
      .where('basicInfo.phoneNumber', '==', phoneNumber)
      .limit(1)
      .get();
    
    if (!existingUserSnap.empty) {
      throw new functions.https.HttpsError('already-exists', 'æ­¤æ‰‹æœºå·ç å·²è¢«ä½¿ç”¨');
    }
    
    // éªŒè¯åˆ†é…é¢åº¦æ˜¯å¦è¶…è¿‡å¯ç”¨é¢åº¦
    const projectInfoRef = getDb().collection('system_config').doc('project_info');
    const projectInfoDoc = await projectInfoRef.get();
    const projectInfo = projectInfoDoc.data();
    const totalCapital = projectInfo.settings?.totalCapital || 0;
    
    const managersSnap = await getDb().collection('users')
      .where('roles', 'array-contains', 'manager')
      .get();
    
    let assignedSum = 0;
    managersSnap.forEach(doc => {
      const managerData = doc.data();
      assignedSum += managerData.roleSpecificData?.manager?.assignedCapital || 0;
    });
    
    if (assignedCapital + assignedSum > totalCapital) {
      throw new functions.https.HttpsError(
        'failed-precondition', 
        `åˆ†é…é¢åº¦è¶…è¿‡å¯ç”¨é¢åº¦,å¯ç”¨: ${totalCapital - assignedSum}`
      );
    }
    
    // ç”Ÿæˆ password hash å’Œ salt
    const passwordSalt = crypto.randomBytes(16).toString('hex');
    const passwordHash = sha256(password + passwordSalt);
    
    // å»ºç«‹ Auth ç”¨æˆ·
    const authUid = `phone_60${phoneNumber.replace(/^0/, "")}`;
    let userRecord;
    
    try {
      userRecord = await admin.auth().createUser({
        uid: authUid,
        displayName: englishName,
        disabled: false
      });
    } catch (authError) {
      if (authError.code === 'auth/uid-already-exists') {
        userRecord = await admin.auth().getUser(authUid);
      } else {
        throw authError;
      }
    }
    
    // ç”Ÿæˆ Manager ID
    const managerIdNum = managersSnap.size + 1;
    const managerId = `M${managerIdNum.toString().padStart(3, '0')}`;
    
    // æ„å»º identityInfo
    let identityInfo = {};
    switch (identityTag) {
      case 'staff':
        identityInfo = {
          staffId: managerId,
          position: 'manager'
        };
        break;
      case 'teacher':
        identityInfo = {
          teacherId: managerId,
          department: 'æ´»åŠ¨ç®¡ç†'
        };
        break;
    }
    
    // å»ºç«‹ Firestore æ–‡æ¡£ - å®Œå…¨ç¬¦åˆæ–°æ¶æ„
    const docId = `usr_${crypto.randomUUID()}`;
    await getDb().collection('users').doc(docId).set({
      userId: docId,
      authUid: userRecord.uid,
      roles: ['manager'],
      identityTag: identityTag,
      basicInfo: {
        phoneNumber: phoneNumber,
        englishName: englishName,
        chineseName: chineseName || '',
        pinHash: passwordHash,
        pinSalt: passwordSalt,
        passwordHash: passwordHash,
        passwordSalt: passwordSalt,
        isPhoneVerified: true
      },
      identityInfo: identityInfo,
      roleSpecificData: {
        manager: {
          managerId: managerId,
          assignedCapital: assignedCapital,
          allocatedToSellers: 0,
          availableCapital: assignedCapital,
          totalSellersManaged: 0,  // åŠ¨æ€è®¡ç®—,ä¸å­˜å‚¨æ•°ç»„
          performance: {
            totalPointsSoldBySellers: 0,
            totalRevenue: 0,
            utilizationRate: 0
          },
          allocationHistory: {
            totalAllocations: 0,
            lastAllocationAt: null,
            totalReclaimed: 0
          },
          capitalSource: {
            assignedBy: callerUid,
            assignedAt: new Date(),
            allocationId: null  // åç»­åˆ›å»ºåˆ†é…è®°å½•æ—¶æ›´æ–°
          }
        }
      },
      activityData: {
        joinedAt: new Date(),
        lastActiveAt: new Date(),
        participationStatus: 'active'
      },
      accountStatus: {
        status: 'active',
        mustChangePassword: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      metadata: {
        registrationSource: 'admin_create',
        operatorUid: callerUid,
        createdBy: callerUid
      }
    });
    
    // æ›´æ–°ç»Ÿè®¡èµ„æ–™
    const newAssignedSum = assignedSum + assignedCapital;
    const newManagerCount = managersSnap.size + 1;
    
    await projectInfoRef.update({
      'statistics.totalManagers': newManagerCount,
      'statistics.assignedCapital': newAssignedSum,
      'statistics.availableCapital': totalCapital - newAssignedSum
    });
    
    console.log('[createManager] Manager created successfully:', docId);
    console.log('[createManager] Updated statistics:', { 
      totalManagers: newManagerCount, 
      assignedCapital: newAssignedSum,
      availableCapital: totalCapital - newAssignedSum
    });
    
    return {
      success: true,
      userId: docId,
      authUid: userRecord.uid,
      managerId: managerId,
      message: 'ç®¡ç†å‘˜å»ºç«‹æˆåŠŸ'
    };
  } catch (error) {
    console.error('[createManager] Error:', error);
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError('internal', error.message || 'å»ºç«‹ç®¡ç†å‘˜å¤±è´¥');
  }
});
```

# src\services\authService.js
```
// src/services/authService.js
import { auth, db, functions } from '../config/firebase';
import { signInWithCustomToken, signOut } from 'firebase/auth';
import { httpsCallable } from 'firebase/functions';
import { query, where, collection, getDocs } from 'firebase/firestore';

/**
 * ğŸ”¥ ä¿®å¾©ï¼šæ¨™æº–åŒ–æ‰‹æ©Ÿè™Ÿç¢¼æ ¼å¼
 */
function normalizePhone(phoneNumber) {
  if (!phoneNumber) return null;
  
  // ç§»é™¤æ‰€æœ‰ç©ºæ ¼å’Œç‰¹æ®Šå­—ç¬¦
  let cleaned = phoneNumber.trim().replace(/[\s\-\(\)]/g, '');
  
  // å¦‚æœä»¥ +60 æˆ– 60 é–‹é ­ï¼Œç§»é™¤å®ƒ
  if (cleaned.startsWith('+60')) {
    cleaned = cleaned.substring(3);
  } else if (cleaned.startsWith('60')) {
    cleaned = cleaned.substring(2);
  }
  
  // å¦‚æœä»¥ 0 é–‹é ­ï¼Œç§»é™¤å®ƒ
  if (cleaned.startsWith('0')) {
    cleaned = cleaned.substring(1);
  }
  
  // é©—è­‰æ ¼å¼ï¼šæ‡‰è©²æ˜¯ 1 é–‹é ­ï¼Œå¾Œæ¥ 8-9 ä½æ•¸å­—ï¼ˆé¦¬ä¾†è¥¿äºæ‰‹æ©Ÿè™Ÿï¼‰
  if (!/^1\d{8,9}$/.test(cleaned)) {
    return null;
  }
  
  // è¿”å›æ¨™æº–æ ¼å¼ï¼š0 + æ•¸å­—ï¼ˆä¾‹å¦‚ï¼š0123456789ï¼‰
  return '0' + cleaned;
}

/**
 * é©—è­‰å¯†ç¢¼å¼·åº¦
 */
function validatePassword(password) {
  if (!password || password.length < 8) return false;
  const hasLetter = /[a-zA-Z]/.test(password);
  const hasNumber = /\d/.test(password);
  return hasLetter && hasNumber;
}

/**
 * ğŸ”¥ ä¿®å¤ï¼šä½¿ç”¨ PIN ç ç™»å…¥
 */
async function loginWithPin(phoneNumber, password, organizationId, eventId) {
  try {
    console.log('[authService] Login attempt:', { 
      phoneNumber, 
      organizationId, 
      eventId 
    });
    
    // éªŒè¯å‚æ•°
    if (!phoneNumber || !password || !organizationId || !eventId) {
      throw new Error('è¯·æä¾›å®Œæ•´çš„ç™»å…¥ä¿¡æ¯');
    }
    
    // æ ‡å‡†åŒ–æ‰‹æœºå·ç 
    const normalized = normalizePhone(phoneNumber);
    if (!normalized) {
      throw new Error('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥ 01 å¼€å¤´çš„ 10-11 ä½æ•°å­—');
    }
    
    console.log('[authService] Normalized phone:', normalized);
    
    // éªŒè¯å¯†ç 
    if (!validatePassword(password)) {
      throw new Error('å¯†ç è‡³å°‘éœ€è¦ 8 ä¸ªå­—ç¬¦ï¼Œä¸”å¿…é¡»åŒ…å«è‹±æ–‡å­—æ¯å’Œæ•°å­—');
    }
    
    // ğŸ”¥ è°ƒç”¨ Cloud Function - ä½¿ç”¨ fetch ç›´æ¥è¯·æ±‚
    console.log('[authService] Calling Cloud Function...');
    
    const functionUrl = 'https://us-central1-mybazaar-c4881.cloudfunctions.net/loginWithPin';
    
    const response = await fetch(functionUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        phoneNumber: normalized,
        pin: password,
        organizationId,
        eventId
      })
    });
    
    console.log('[authService] Response status:', response.status);
    
    if (!response.ok) {
      let errorData;
      try {
        errorData = await response.json();
      } catch (e) {
        const errorText = await response.text();
        console.error('[authService] Error response text:', errorText);
        throw new Error(`æœåŠ¡å™¨é”™è¯¯ (${response.status}): ${errorText}`);
      }
      
      console.error('[authService] Error response:', errorData);
      throw new Error(errorData.error?.message || `HTTP error! status: ${response.status}`);
    }
    
    const result = await response.json();
    
    console.log('[authService] Cloud Function response received');
    console.log('[authService] Response data:', {
      hasCustomToken: !!result?.customToken,
      hasUserProfile: !!result?.userProfile,
      success: result?.success
    });
    
    if (!result?.customToken) {
      console.error('[authService] No custom token in response:', result);
      throw new Error(result?.error?.message || 'ç™»å…¥å¤±è´¥ï¼šæœªæ”¶åˆ°è®¤è¯ä»¤ç‰Œ');
    }
    
    // ğŸ”¥ ä½¿ç”¨è‡ªå®šä¹‰ä»¤ç‰Œç™»å…¥ Firebase Auth
    console.log('[authService] Signing in with custom token...');
    try {
      const userCredential = await signInWithCustomToken(auth, result.customToken);
      console.log('[authService] Firebase Auth sign-in successful:', userCredential.user.uid);
    } catch (authError) {
      console.error('[authService] Firebase Auth error:', {
        code: authError.code,
        message: authError.message,
        stack: authError.stack
      });
      
      // æä¾›æ›´è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯
      if (authError.code === 'auth/invalid-custom-token') {
        throw new Error('è®¤è¯ä»¤ç‰Œæ— æ•ˆï¼Œè¯·é‡è¯•');
      } else if (authError.code === 'auth/custom-token-mismatch') {
        throw new Error('è®¤è¯é…ç½®é”™è¯¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜');
      } else {
        throw new Error(`è®¤è¯å¤±è´¥: ${authError.message}`);
      }
    }
    
    return {
      success: true,
      user: result,
      userProfile: result.userProfile,
      message: 'ç™»å…¥æˆåŠŸ'
    };
    
  } catch (error) {
    console.error('[authService] Login error:', {
      name: error.name,
      code: error.code,
      message: error.message,
      stack: error.stack
    });
    
    // ğŸ”¥ ç»Ÿä¸€é”™è¯¯å¤„ç†
    let errorMessage = 'ç™»å…¥å¤±è´¥';
    
    if (error.code === 'not-found') {
      errorMessage = 'æŸ¥æ— æ­¤æ‰‹æœºå·ç ï¼Œè¯·ç¡®è®¤åé‡è¯•';
    } else if (error.code === 'permission-denied') {
      errorMessage = 'å¯†ç é”™è¯¯ï¼Œè¯·é‡æ–°è¾“å…¥';
    } else if (error.code === 'invalid-argument') {
      errorMessage = error.message || 'è¾“å…¥èµ„æ–™æ ¼å¼ä¸æ­£ç¡®';
    } else if (error.code === 'internal') {
      errorMessage = 'æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•';
    } else if (error.code === 'unavailable' || error.code === 'deadline-exceeded') {
      errorMessage = 'ç½‘ç»œè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•';
    } else if (error.message.includes('Failed to fetch')) {
      errorMessage = 'æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
    } else if (error.message) {
      errorMessage = error.message;
    }
    
    throw new Error(errorMessage);
  }
}

/**
 * ç™»å‡º
 */
async function logout() {
  try {
    await signOut(auth);
    console.log('[authService] Logout successful');
  } catch (error) {
    console.error('[authService] Logout error:', error);
    throw error;
  }
}

/**
 * ğŸ”¥ ä¿®å¾©ï¼šæ ¹æ“š authUid ç²å–ç”¨æˆ¶è³‡æ–™
 */
async function getUserProfile(authUid, orgId, eventId) {
  if (!authUid || !orgId || !eventId) {
    throw new Error('getUserProfile requires authUid, orgId, and eventId');
  }

  try {
    const userCollectionPath = `organizations/${orgId}/events/${eventId}/users`;
    console.log('[authService] Querying user from:', userCollectionPath);
    
    const q = query(
      collection(db, userCollectionPath),
      where('authUid', '==', authUid)
    );
    
    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      // ğŸ”¥ å˜—è©¦æŸ¥è©¢å…¶ä»–å¯èƒ½çš„ authUid å­—æ®µ
      const alternativeFields = ['accountStatus.authUid', 'authId', 'authMid'];
      
      for (const field of alternativeFields) {
        const altQ = query(
          collection(db, userCollectionPath),
          where(field, '==', authUid)
        );
        
        const altSnapshot = await getDocs(altQ);
        if (!altSnapshot.empty) {
          console.log(`[authService] Found user with ${field}`);
          const userDoc = altSnapshot.docs[0];
          return {
            id: userDoc.id,
            orgId,
            eventId,
            ...userDoc.data()
          };
        }
      }
      
      console.warn('[authService] No user profile found for authUid:', authUid);
      return null;
    }
    
    const userDoc = querySnapshot.docs[0];
    return {
      id: userDoc.id,
      orgId,
      eventId,
      ...userDoc.data()
    };
  } catch (error) {
    console.error('[authService] Error getting user profile:', error);
    throw error;
  }
}

/**
 * ä¿®æ”¹å¯†ç¢¼
 */
async function changePassword(phoneNumber, currentPassword, newPassword) {
  try {
    const normalized = normalizePhone(phoneNumber);
    if (!normalized) {
      throw new Error('æ‰‹æ©Ÿè™Ÿæ ¼å¼ä¸æ­£ç¢º');
    }

    if (!validatePassword(newPassword)) {
      throw new Error('æ–°å¯†ç¢¼è‡³å°‘éœ€è¦ 8 å€‹å­—ç¬¦ï¼Œä¸”å¿…é ˆåŒ…å«è‹±æ–‡å­—æ¯å’Œæ•¸å­—');
    }

    const changePasswordFn = httpsCallable(functions, 'changePassword');
    const result = await changePasswordFn({
      phoneNumber: normalized,
      currentPassword,
      newPassword
    });

    return result.data;
  } catch (error) {
    console.error('[authService] Change password error:', error);
    throw new Error(error.message || 'ä¿®æ”¹å¯†ç¢¼å¤±æ•—');
  }
}

/**
 * ç™¼é€ OTP
 */
async function sendOtp(phoneNumber, pinCode) {
  try {
    const normalized = normalizePhone(phoneNumber);
  
```
# src\contexts\AuthContext.jsx
```
// src/contexts/AuthContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import { auth } from '../config/firebase';
import { onAuthStateChanged } from 'firebase/auth';
import { authService } from '../services/authService';
import { useEvent } from './EventContext';

const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null);
  const [userProfile, setUserProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  const { organizationId, eventId } = useEvent();

  // ç›‘å¬ Firebase Auth çŠ¶æ€å˜åŒ–
  useEffect(() => {
    if (!organizationId || !eventId) {
      console.warn('[AuthContext] No organizationId or eventId');
      setLoading(false);
      return;
    }

    const unsubscribe = onAuthStateChanged(auth, async (user) => {
      console.log('[AuthContext] Auth state changed:', user ? user.uid : 'no user');
      
      if (user && !user.isAnonymous) {
        setCurrentUser(user);
        
        // ğŸ”¥ æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰ç”¨æˆ·èµ„æ–™ï¼ˆä»ç™»å½•æ—¶è·å¾—ï¼‰
        if (!userProfile) {
          // å¦‚æœæ²¡æœ‰ï¼Œå°è¯•ä» Firestore åŠ è½½ï¼ˆéœ€è¦æ­£ç¡®çš„æƒé™ï¼‰
          try {
            const profile = await authService.getUserProfile(
              user.uid, 
              organizationId, 
              eventId
            );
            setUserProfile(profile);
            console.log('[AuthContext] User profile loaded from Firestore:', profile);
          } catch (err) {
            console.error('[AuthContext] Failed to load user profile:', err);
            // ä¸è®¾ç½®ä¸º nullï¼Œä¿ç•™å·²æœ‰çš„ userProfile
          }
        }
      } else {
        setCurrentUser(null);
        setUserProfile(null);
      }
      
      setLoading(false);
    });

    return () => unsubscribe();
  }, [organizationId, eventId, userProfile]);

  // ç™»å…¥å‡½æ•°
  const login = async (phoneNumber, password) => {
    try {
      setError(null);
      setLoading(true);
      
      console.log('[AuthContext] Login called');
      
      if (!organizationId || !eventId) {
        throw new Error('æ— æ³•è·å–ç»„ç»‡æˆ–æ´»åŠ¨ä¿¡æ¯ï¼Œè¯·é‡æ–°åŠ è½½é¡µé¢');
      }
      
      const result = await authService.loginWithPin(phoneNumber, password, organizationId, eventId);
      
      // ğŸ”¥ å¦‚æœç™»å½•è¿”å›äº†ç”¨æˆ·èµ„æ–™ï¼Œç›´æ¥è®¾ç½®
      if (result.userProfile) {
        setUserProfile(result.userProfile);
        console.log('[AuthContext] User profile set from login result:', result.userProfile);
      }
      
      return result;
    } catch (err) {
      console.error('[AuthContext] Login error:', err);
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  };

  const logout = async () => {
    try {
      await authService.logout();
      setCurrentUser(null);
      setUserProfile(null);
    } catch (err) {
      console.error('[AuthContext] Logout error:', err);
      throw err;
    }
  };

  // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰ç‰¹å®šè§’è‰²
  const hasRole = (role) => {
    if (!userProfile || !userProfile.roles) return false;
    return userProfile.roles.includes(role);
  };

  // è·å–ç”¨æˆ·ä¸»è¦è§’è‰²ï¼ˆä¼˜å…ˆçº§æœ€é«˜çš„è§’è‰²ï¼‰
  const getPrimaryRole = () => {
    if (!userProfile || !userProfile.roles) return null;
    
    const rolePriority = [
      'platform_admin',
      'org_admin', 
      'event_manager',
      'manager',
      'merchant',
      'seller',
      'customer'
    ];
    
    for (const role of rolePriority) {
      if (userProfile.roles.includes(role)) {
        return role;
      }
    }
    
    return null;
  };

  const value = {
    currentUser,
    userProfile,
    loading,
    error,
    login,
    logout,
    hasRole,
    getPrimaryRole,
    isAuthenticated: !!currentUser && !currentUser.isAnonymous
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};
```
# src\contexts\EventContext.jsx
```
// src/contexts/EventContext.jsx
import { createContext, useContext, useState, useEffect } from 'react';
import { db } from '../config/firebase';
import { collection, query, where, getDocs } from 'firebase/firestore';

const EventContext = createContext();

export const useEvent = () => {
  const context = useContext(EventContext);
  if (!context) {
    throw new Error('useEvent must be used within EventProvider');
  }
  return context;
};

export const EventProvider = ({ children }) => {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [organizationId, setOrganizationId] = useState(null);
  const [eventId, setEventId] = useState(null);
  const [organization, setOrganization] = useState(null);
  const [event, setEvent] = useState(null);
  const [orgCode, setOrgCode] = useState(null);
  const [eventCode, setEventCode] = useState(null);

  useEffect(() => {
    parseUrlAndLoadData();
  }, []);

  const parseUrlAndLoadData = async () => {
    try {
      setLoading(true);
      setError(null);

      // ğŸ”¥ æ”¹è¿›çš„ URL è§£æ
      // æ”¯æŒæ ¼å¼: /orgCode-eventCode/platform/page
      // ä¾‹å¦‚: /xhessbn-2025/desktop/login
      const urlPath = window.location.pathname;
      console.log('[EventContext] è§£æ URL:', urlPath);

      // ğŸ”¥ æ›´çµæ´»çš„æ­£åˆ™è¡¨è¾¾å¼
      // åŒ¹é…: /orgCode-eventCode/platform
      const match = urlPath.match(/\/([a-z0-9]+)-([a-z0-9\-]+)\/(phone|desktop)/i);

      if (!match) {
        console.warn('[EventContext] URL æ ¼å¼æ— æ³•è¯†åˆ«:', urlPath);
        console.log('[EventContext] é¢„æœŸæ ¼å¼: /orgCode-eventCode/platform');
        console.log('[EventContext] ä¾‹å¦‚: /xhessbn-2025/desktop/login');
        setError('URL æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ä½¿ç”¨æ­£ç¡®çš„é“¾æ¥\nä¾‹å¦‚: /xhessbn-2025/desktop/login');
        setLoading(false);
        return;
      }

      const parsedOrgCode = match[1];
      const parsedEventCode = match[2];

      console.log('[EventContext] ä» URL è§£æå‡º:', {
        orgCode: parsedOrgCode,
        eventCode: parsedEventCode,
        platform: match[3]
      });

      setOrgCode(parsedOrgCode);
      setEventCode(parsedEventCode);

      // è½½å…¥æ•°æ®
      await loadEventData(parsedOrgCode, parsedEventCode);

    } catch (err) {
      console.error('[EventContext] è§£æé”™è¯¯:', err);
      setError(err.message);
      setLoading(false);
    }
  };

  const loadEventData = async (orgCode, eventCode) => {
    try {
      console.log('[EventContext] è½½å…¥æ•°æ®:', { orgCode, eventCode });

      // 1. ğŸ”¥ æŸ¥æ‰¾ç»„ç»‡ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
      const orgsSnapshot = await getDocs(collection(db, 'organizations'));
      
      console.log(`[EventContext] æ‰¾åˆ° ${orgsSnapshot.size} ä¸ªç»„ç»‡`);

      let orgDoc = null;
      orgsSnapshot.forEach(doc => {
        const data = doc.data();
        console.log(`[EventContext] æ£€æŸ¥ç»„ç»‡: ${data.orgCode}`);
        if (data.orgCode && data.orgCode.toLowerCase() === orgCode.toLowerCase()) {
          orgDoc = doc;
        }
      });

      if (!orgDoc) {
        // ğŸ”¥ æä¾›æ›´æœ‰å¸®åŠ©çš„é”™è¯¯ä¿¡æ¯
        const availableOrgs = [];
        orgsSnapshot.forEach(doc => {
          availableOrgs.push(doc.data().orgCode);
        });
        
        console.error('[EventContext] å¯ç”¨çš„ç»„ç»‡:', availableOrgs);
        throw new Error(
          `æ‰¾ä¸åˆ°ç»„ç»‡ä»£ç : ${orgCode}\n` +
          `å¯ç”¨çš„ç»„ç»‡: ${availableOrgs.join(', ')}\n` +
          `è¯·æ£€æŸ¥ URL æ˜¯å¦æ­£ç¡®`
        );
      }

      const orgId = orgDoc.id;
      const orgData = orgDoc.data();

      console.log('[EventContext] æ‰¾åˆ°ç»„ç»‡:', {
        id: orgId,
        orgCode: orgData.orgCode
      });

      setOrganizationId(orgId);
      setOrganization({ id: orgId, ...orgData });

      // 2. ğŸ”¥ æŸ¥æ‰¾æ´»åŠ¨ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
      const eventsCollectionPath = `organizations/${orgId}/events`;
      console.log('[EventContext] æŸ¥è¯¢æ´»åŠ¨è·¯å¾„:', eventsCollectionPath);

      const eventsSnapshot = await getDocs(
        collection(db, 'organizations', orgId, 'events')
      );

      console.log(`[EventContext] æ‰¾åˆ° ${eventsSnapshot.size} ä¸ªæ´»åŠ¨`);

      let eventDoc = null;
      eventsSnapshot.forEach(doc => {
        const data = doc.data();
        console.log(`[EventContext] æ£€æŸ¥æ´»åŠ¨: ${data.eventCode}`);
        if (data.eventCode && data.eventCode.toLowerCase() === eventCode.toLowerCase()) {
          eventDoc = doc;
        }
      });

      if (!eventDoc) {
        // ğŸ”¥ æä¾›æ›´æœ‰å¸®åŠ©çš„é”™è¯¯ä¿¡æ¯
        const availableEvents = [];
        eventsSnapshot.forEach(doc => {
          availableEvents.push(doc.data().eventCode);
        });

        console.error('[EventContext] å¯ç”¨çš„æ´»åŠ¨:', availableEvents);
        throw new Error(
          `æ‰¾ä¸åˆ°æ´»åŠ¨ä»£ç : ${eventCode}\n` +
          `å¯ç”¨çš„æ´»åŠ¨: ${availableEvents.join(', ')}\n` +
          `è¯·æ£€æŸ¥ URL æ˜¯å¦æ­£ç¡®`
        );
      }

      const evtId = eventDoc.id;
      const evtData = eventDoc.data();

      console.log('[EventContext] æ‰¾åˆ°æ´»åŠ¨:', {
        id: evtId,
        eventCode: evtData.eventCode
      });

      setEventId(evtId);
      setEvent({ id: evtId, ...evtData });

      console.log('[EventContext] âœ… è½½å…¥æˆåŠŸ:', {
        orgCode: orgData.orgCode,
        eventCode: evtData.eventCode,
        orgId,
        eventId: evtId
      });

      setLoading(false);

    } catch (err) {
      console.error('[EventContext] è½½å…¥é”™è¯¯:', err);
      setError(err.message);
      setLoading(false);
      throw err;
    }
  };

  // è·å–é›†åˆè·¯å¾„ï¼ˆè‡ªåŠ¨åŠ ä¸Š org å’Œ event å‰ç¼€ï¼‰
  const getCollectionPath = (collectionName) => {
    if (!organizationId || !eventId) {
      throw new Error('ç»„ç»‡æˆ–æ´»åŠ¨å°šæœªè½½å…¥');
    }
    return `organizations/${organizationId}/events/${eventId}/${collectionName}`;
  };

  // è·å– Firestore é›†åˆå¼•ç”¨
  const getCollection = (collectionName) => {
    return collection(db, getCollectionPath(collectionName));
  };

  const value = {
    loading,
    error,
    organizationId,
    eventId,
    organization,
    event,
    orgCode,
    eventCode,
    getCollectionPath,
    getCollection,
    reload: parseUrlAndLoadData
  };

  // ğŸ”¥ æ·»åŠ é”™è¯¯æ˜¾ç¤º
  if (error) {
    return (
      <EventContext.Provider value={value}>
        <div style={{
          padding: '2rem',
          maxWidth: '600px',
          margin: '2rem auto',
          background: '#fee2e2',
          border: '1px solid #fecaca',
          borderRadius: '8px',
          color: '#991b1b'
        }}>
          <h2 style={{ margin: '0 0 1rem 0' }}>âŒ è½½å…¥å¤±è´¥</h2>
          <pre style={{
            whiteSpace: 'pre-wrap',
            wordBreak: 'break-word',
            margin: '1rem 0',
            padding: '1rem',
            background: 'white',
            borderRadius: '4px'
          }}>
            {error}
          </pre>
          <p>è¯·æ£€æŸ¥ï¼š</p>
          <ul>
            <li>URL æ ¼å¼æ˜¯å¦æ­£ç¡®</li>
            <li>ç»„ç»‡å’Œæ´»åŠ¨ä»£ç æ˜¯å¦å­˜åœ¨äº Firestore</li>
            <li>ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸</li>
          </ul>
          <button
            onClick={() => window.location.reload()}
            style={{
              padding: '0.5rem 1rem',
              background: '#991b1b',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer',
              marginTop: '1rem'
            }}
          >
            é‡æ–°è½½å…¥
          </button>
        </div>
      </EventContext.Provider>
    );
  }

  if (loading) {
    return (
      <EventContext.Provider value={value}>
        <div style={{
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          minHeight: '100vh'
        }}>
          <div style={{ textAlign: 'center' }}>
            <div style={{
              width: '50px',
              height: '50px',
              border: '4px solid #f3f4f6',
              borderTopColor: '#667eea',
              borderRadius: '50%',
              animation: 'spin 1s linear infinite',
              margin: '0 auto 1rem'
            }} />
            <p style={{ color: '#6b7280' }}>è½½å…¥ä¸­...</p>
          </div>
        </div>
      </EventContext.Provider>
    );
  }

  return (
    <EventContext.Provider value={value}>
      {children}
    </EventContext.Provider>
  );
};

// æ·»åŠ æ—‹è½¬åŠ¨ç”»
if (typeof document !== 'undefined') {
  const style = document.createElement('style');
  style.textContent = `
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  `;
  document.head.appendChild(style);
}
```

# src\views\desktop\auth\Login.jsx
```
// src/views/phone/auth/Login.jsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useAuth } from '../../../contexts/AuthContext';
import { useEvent } from '../../../contexts/EventContext';

const PhoneLogin = () => {
  const navigate = useNavigate();
  const { login } = useAuth();
  const { orgCode, eventCode } = useEvent();

  const [formData, setFormData] = useState({
    phoneNumber: '',
    password: ''
  });
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    // æ¸…é™¤é”™è¯¯ä¿¡æ¯
    if (error) setError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // åŸºæœ¬éªŒè¯
    if (!formData.phoneNumber || !formData.password) {
      setError('è¯·å¡«å†™å®Œæ•´çš„æ‰‹æœºå·å’Œå¯†ç ');
      return;
    }

    // éªŒè¯æ‰‹æœºå·æ ¼å¼
    if (!/^01\d{8,9}$/.test(formData.phoneNumber)) {
      setError('æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥01å¼€å¤´çš„10-11ä½æ•°å­—');
      return;
    }

    // éªŒè¯å¯†ç é•¿åº¦
    if (formData.password.length < 8) {
      setError('å¯†ç è‡³å°‘éœ€è¦8ä¸ªå­—ç¬¦');
      return;
    }

    try {
      setLoading(true);
      setError('');

      await login(formData.phoneNumber, formData.password);

      // ç™»å½•æˆåŠŸï¼Œè·³è½¬åˆ°æ‰‹æœºç‰ˆé¦–é¡µ
      navigate(`/${orgCode}-${eventCode}/phone`);
    } catch (err) {
      console.error('[PhoneLogin] Login failed:', err);
      setError(err.message || 'ç™»å½•å¤±è´¥ï¼Œè¯·é‡è¯•');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div style={styles.container}>
      <div style={styles.card}>
        <div style={styles.header}>
          <h1 style={styles.title}>ç”¨æˆ·ç™»å½•</h1>
          <p style={styles.subtitle}>è¯·è¾“å…¥æ‚¨çš„æ‰‹æœºå·å’Œå¯†ç </p>
        </div>

        <form onSubmit={handleSubmit} style={styles.form}>
          <div style={styles.formGroup}>
            <label style={styles.label}>æ‰‹æœºå·</label>
            <input
              type="tel"
              name="phoneNumber"
              value={formData.phoneNumber}
              onChange={handleChange}
              placeholder="01xxxxxxxx"
              style={styles.input}
              disabled={loading}
              inputMode="numeric"
              pattern="^01\d{8,9}$"
              maxLength="11"
            />
            <small style={styles.hint}>é©¬æ¥è¥¿äºšæ‰‹æœºå·ï¼Œ01å¼€å¤´</small>
          </div>

          <div style={styles.formGroup}>
            <label style={styles.label}>å¯†ç </label>
            <input
              type="password"
              name="password"
              value={formData.password}
              onChange={handleChange}
              placeholder="è‡³å°‘8ä½ï¼ŒåŒ…å«è‹±æ–‡å’Œæ•°å­—"
              style={styles.input}
              disabled={loading}
              minLength="8"
            />
          </div>

          {error && (
            <div style={styles.errorMessage}>
              âš ï¸ {error}
            </div>
          )}

          <button
            type="submit"
            style={{
              ...styles.submitButton,
              ...(loading ? styles.submitButtonDisabled : {})
            }}
            disabled={loading}
          >
            {loading ? 'ç™»å½•ä¸­...' : 'ç™»å½•'}
          </button>
        </form>

        <div style={styles.footer}>
          <p style={styles.footerText}>
            è¿˜æ²¡æœ‰è´¦å·ï¼Ÿè¯·è”ç³»ç®¡ç†å‘˜æ³¨å†Œ
          </p>
        </div>
      </div>
    </div>
  );
};

const styles = {
  container: {
    minHeight: '100vh',
    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: '1rem'
  },
  card: {
    background: 'white',
    borderRadius: '16px',
    padding: '2rem',
    width: '100%',
    maxWidth: '400px',
    boxShadow: '0 10px 40px rgba(0, 0, 0, 0.2)'
  },
  header: {
    textAlign: 'center',
    marginBottom: '2rem'
  },
  title: {
    fontSize: '1.75rem',
    fontWeight: 'bold',
    color: '#1f2937',
    margin: '0 0 0.5rem 0'
  },
  subtitle: {
    fontSize: '0.875rem',
    color: '#6b7280',
    margin: 0
  },
  form: {
    display: 'flex',
    flexDirection: 'column',
    gap: '1.5rem'
  },
  formGroup: {
    display: 'flex',
    flexDirection: 'column',
    gap: '0.5rem'
  },
  label: {
    fontSize: '0.875rem',
    fontWeight: '600',
    color: '#374151'
  },
  input: {
    padding: '0.75rem',
    fontSize: '1rem',
    border: '1px solid #d1d5db',
    borderRadius: '8px',
    outline: 'none',
    transition: 'border-color 0.2s',
    width: '100%',
    boxSizing: 'border-box'
  },
  hint: {
    fontSize: '0.75rem',
    color: '#6b7280'
  },
  errorMessage: {
    padding: '0.75rem',
    background: '#fee2e2',
    color: '#991b1b',
    borderRadius: '8px',
    fontSize: '0.875rem',
    border: '1px solid #fecaca'
  },
  submitButton: {
    padding: '0.875rem',
    fontSize: '1rem',
    fontWeight: '600',
    color: 'white',
    background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
    border: 'none',
    borderRadius: '8px',
    cursor: 'pointer',
    transition: 'transform 0.2s, opacity 0.2s',
    marginTop: '0.5rem'
  },
  submitButtonDisabled: {
    opacity: 0.6,
    cursor: 'not-allowed'
  },
  footer: {
    marginTop: '1.5rem',
    paddingTop: '1.5rem',
    borderTop: '1px solid #e5e7eb',
    textAlign: 'center'
  },
  footerText: {
    fontSize: '0.875rem',
    color: '#6b7280',
    margin: 0
  }
};

export default PhoneLogin;
```
